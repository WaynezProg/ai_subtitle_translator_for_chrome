/**
 * Tests for Adapter Types
 */

import { describe, it, expect } from 'vitest';
import {
  AdapterError,
  DEFAULT_RENDER_OPTIONS,
  type URLPattern,
  type SubtitleTrack,
  type RawSubtitle,
  type RenderOptions,
  type VideoEvent,
  type AdapterErrorCode,
} from '../../../src/content/adapters/types';
import type { Platform } from '../../../src/shared/types/subtitle';

describe('Adapter Types', () => {
  describe('AdapterError', () => {
    it('should create error with code, message, and platform', () => {
      const error = new AdapterError('VIDEO_NOT_FOUND', 'Video element not found', 'youtube');

      expect(error.code).toBe('VIDEO_NOT_FOUND');
      expect(error.message).toBe('Video element not found');
      expect(error.platform).toBe('youtube');
      expect(error.name).toBe('AdapterError');
    });

    it('should be an instance of Error', () => {
      const error = new AdapterError('INITIALIZATION_FAILED', 'Failed to init', 'netflix');

      expect(error).toBeInstanceOf(Error);
      expect(error).toBeInstanceOf(AdapterError);
    });

    it('should support all error codes', () => {
      const errorCodes: AdapterErrorCode[] = [
        'INITIALIZATION_FAILED',
        'VIDEO_NOT_FOUND',
        'SUBTITLE_FETCH_FAILED',
        'SUBTITLE_PARSE_FAILED',
        'INJECTION_FAILED',
        'PLATFORM_UPDATED',
        'UNSUPPORTED_CONTENT',
      ];

      errorCodes.forEach(code => {
        const error = new AdapterError(code, `Error: ${code}`, 'youtube');
        expect(error.code).toBe(code);
      });
    });

    it('should support all platforms', () => {
      const platforms: Platform[] = ['youtube', 'netflix', 'disneyplus', 'primevideo'];

      platforms.forEach(platform => {
        const error = new AdapterError('VIDEO_NOT_FOUND', 'Video not found', platform);
        expect(error.platform).toBe(platform);
      });
    });

    it('should have proper stack trace', () => {
      const error = new AdapterError('INJECTION_FAILED', 'Could not inject', 'disneyplus');

      expect(error.stack).toBeDefined();
      expect(error.stack).toContain('AdapterError');
    });
  });

  describe('DEFAULT_RENDER_OPTIONS', () => {
    it('should have correct default values', () => {
      expect(DEFAULT_RENDER_OPTIONS.fontSize).toBe(28);
      expect(DEFAULT_RENDER_OPTIONS.fontColor).toBe('#FFFFFF');
      expect(DEFAULT_RENDER_OPTIONS.position).toBe('bottom');
      expect(DEFAULT_RENDER_OPTIONS.bilingual).toBe(true);
      expect(DEFAULT_RENDER_OPTIONS.bilingualOrder).toBe('original-first');
      expect(DEFAULT_RENDER_OPTIONS.background).toBe('box');
      expect(DEFAULT_RENDER_OPTIONS.fontFamily).toBe('system-ui, -apple-system, sans-serif');
      expect(DEFAULT_RENDER_OPTIONS.hideNativeSubtitles).toBe(true);
    });

    it('should be a valid RenderOptions object', () => {
      const options: RenderOptions = DEFAULT_RENDER_OPTIONS;

      expect(typeof options.fontSize).toBe('number');
      expect(typeof options.fontColor).toBe('string');
      expect(['top', 'bottom']).toContain(options.position);
      expect(typeof options.bilingual).toBe('boolean');
      expect(['original-first', 'translation-first']).toContain(options.bilingualOrder);
      expect(['none', 'shadow', 'box']).toContain(options.background);
      expect(typeof options.fontFamily).toBe('string');
    });

    it('should be immutable-like (no modification in tests)', () => {
      // Store original value
      const originalFontSize = DEFAULT_RENDER_OPTIONS.fontSize;

      // Verify the value hasn't changed from expected default
      expect(originalFontSize).toBe(28);
    });
  });

  describe('Type Structure Validation', () => {
    describe('URLPattern', () => {
      it('should accept valid URLPattern objects', () => {
        const pattern: URLPattern = {
          pattern: /youtube\.com\/watch/,
          type: 'main',
        };

        expect(pattern.pattern).toBeInstanceOf(RegExp);
        expect(pattern.type).toBe('main');
      });

      it('should accept embed type', () => {
        const pattern: URLPattern = {
          pattern: /youtube\.com\/embed/,
          type: 'embed',
        };

        expect(pattern.type).toBe('embed');
      });
    });

    describe('SubtitleTrack', () => {
      it('should accept valid SubtitleTrack objects', () => {
        const track: SubtitleTrack = {
          id: 'track-1',
          language: 'en-US',
          label: 'English',
          url: 'https://example.com/subtitles.vtt',
          format: 'webvtt',
          isAutoGenerated: false,
          isDefault: true,
        };

        expect(track.id).toBe('track-1');
        expect(track.language).toBe('en-US');
        expect(track.label).toBe('English');
        expect(track.url).toContain('example.com');
        expect(track.format).toBe('webvtt');
        expect(track.isAutoGenerated).toBe(false);
        expect(track.isDefault).toBe(true);
      });

      it('should support auto-generated tracks', () => {
        const track: SubtitleTrack = {
          id: 'asr-track',
          language: 'en',
          label: 'English (auto-generated)',
          url: 'https://example.com/asr.vtt',
          format: 'webvtt',
          isAutoGenerated: true,
          isDefault: false,
        };

        expect(track.isAutoGenerated).toBe(true);
      });

      it('should support different formats', () => {
        const formats: Array<SubtitleTrack['format']> = ['webvtt', 'ttml', 'srt', 'json3'];

        formats.forEach(format => {
          const track: SubtitleTrack = {
            id: 'track',
            language: 'en',
            label: 'English',
            url: 'https://example.com/subs',
            format,
            isAutoGenerated: false,
            isDefault: false,
          };
          expect(track.format).toBe(format);
        });
      });
    });

    describe('RawSubtitle', () => {
      it('should accept valid RawSubtitle objects', () => {
        const raw: RawSubtitle = {
          content: 'WEBVTT\n\n00:00:00.000 --> 00:00:05.000\nHello World',
          format: 'webvtt',
        };

        expect(raw.content).toContain('WEBVTT');
        expect(raw.format).toBe('webvtt');
      });

      it('should support optional metadata', () => {
        const raw: RawSubtitle = {
          content: '<tt>...</tt>',
          format: 'ttml',
          metadata: {
            duration: 3600,
            language: 'en',
            source: 'netflix',
          },
        };

        expect(raw.metadata).toBeDefined();
        expect(raw.metadata?.duration).toBe(3600);
      });

      it('should work without metadata', () => {
        const raw: RawSubtitle = {
          content: '{}',
          format: 'json3',
        };

        expect(raw.metadata).toBeUndefined();
      });
    });

    describe('RenderOptions', () => {
      it('should accept all position values', () => {
        const positions: Array<RenderOptions['position']> = ['top', 'bottom'];

        positions.forEach(position => {
          const options: RenderOptions = {
            ...DEFAULT_RENDER_OPTIONS,
            position,
          };
          expect(options.position).toBe(position);
        });
      });

      it('should accept all background values', () => {
        const backgrounds: Array<RenderOptions['background']> = ['none', 'shadow', 'box'];

        backgrounds.forEach(background => {
          const options: RenderOptions = {
            ...DEFAULT_RENDER_OPTIONS,
            background,
          };
          expect(options.background).toBe(background);
        });
      });

      it('should accept all bilingual order values', () => {
        const orders: Array<RenderOptions['bilingualOrder']> = ['original-first', 'translation-first'];

        orders.forEach(order => {
          const options: RenderOptions = {
            ...DEFAULT_RENDER_OPTIONS,
            bilingualOrder: order,
          };
          expect(options.bilingualOrder).toBe(order);
        });
      });

      it('should support custom font settings', () => {
        const options: RenderOptions = {
          ...DEFAULT_RENDER_OPTIONS,
          fontSize: 32,
          fontColor: '#FFCC00',
          fontFamily: 'Arial, sans-serif',
        };

        expect(options.fontSize).toBe(32);
        expect(options.fontColor).toBe('#FFCC00');
        expect(options.fontFamily).toBe('Arial, sans-serif');
      });
    });

    describe('VideoEvent', () => {
      it('should support play event', () => {
        const event: VideoEvent = { type: 'play' };
        expect(event.type).toBe('play');
      });

      it('should support pause event', () => {
        const event: VideoEvent = { type: 'pause' };
        expect(event.type).toBe('pause');
      });

      it('should support seeked event with currentTime', () => {
        const event: VideoEvent = { type: 'seeked', currentTime: 120.5 };
        expect(event.type).toBe('seeked');
        expect(event.currentTime).toBe(120.5);
      });

      it('should support timeupdate event with currentTime', () => {
        const event: VideoEvent = { type: 'timeupdate', currentTime: 45.123 };
        expect(event.type).toBe('timeupdate');
        expect(event.currentTime).toBe(45.123);
      });

      it('should support ended event', () => {
        const event: VideoEvent = { type: 'ended' };
        expect(event.type).toBe('ended');
      });

      it('should support ratechange event with playbackRate', () => {
        const event: VideoEvent = { type: 'ratechange', playbackRate: 1.5 };
        expect(event.type).toBe('ratechange');
        expect(event.playbackRate).toBe(1.5);
      });

      it('should handle all video event types in switch', () => {
        const events: VideoEvent[] = [
          { type: 'play' },
          { type: 'pause' },
          { type: 'seeked', currentTime: 0 },
          { type: 'timeupdate', currentTime: 0 },
          { type: 'ended' },
          { type: 'ratechange', playbackRate: 1 },
        ];

        const handleEvent = (event: VideoEvent): string => {
          switch (event.type) {
            case 'play':
              return 'playing';
            case 'pause':
              return 'paused';
            case 'seeked':
              return `seeked to ${event.currentTime}`;
            case 'timeupdate':
              return `time ${event.currentTime}`;
            case 'ended':
              return 'ended';
            case 'ratechange':
              return `rate ${event.playbackRate}`;
          }
        };

        expect(handleEvent(events[0])).toBe('playing');
        expect(handleEvent(events[1])).toBe('paused');
        expect(handleEvent(events[2])).toBe('seeked to 0');
        expect(handleEvent(events[3])).toBe('time 0');
        expect(handleEvent(events[4])).toBe('ended');
        expect(handleEvent(events[5])).toBe('rate 1');
      });
    });
  });

  describe('Error Code Coverage', () => {
    it('INITIALIZATION_FAILED should be used for adapter init errors', () => {
      const error = new AdapterError(
        'INITIALIZATION_FAILED',
        'Failed to initialize YouTube adapter',
        'youtube'
      );
      expect(error.code).toBe('INITIALIZATION_FAILED');
    });

    it('VIDEO_NOT_FOUND should be used when video element is missing', () => {
      const error = new AdapterError(
        'VIDEO_NOT_FOUND',
        'No video element found on page',
        'netflix'
      );
      expect(error.code).toBe('VIDEO_NOT_FOUND');
    });

    it('SUBTITLE_FETCH_FAILED should be used for network errors', () => {
      const error = new AdapterError(
        'SUBTITLE_FETCH_FAILED',
        'Failed to fetch subtitle from server',
        'disneyplus'
      );
      expect(error.code).toBe('SUBTITLE_FETCH_FAILED');
    });

    it('SUBTITLE_PARSE_FAILED should be used for parsing errors', () => {
      const error = new AdapterError(
        'SUBTITLE_PARSE_FAILED',
        'Invalid WebVTT format',
        'primevideo'
      );
      expect(error.code).toBe('SUBTITLE_PARSE_FAILED');
    });

    it('INJECTION_FAILED should be used when subtitle injection fails', () => {
      const error = new AdapterError(
        'INJECTION_FAILED',
        'Could not inject subtitles into player',
        'youtube'
      );
      expect(error.code).toBe('INJECTION_FAILED');
    });

    it('PLATFORM_UPDATED should be used when platform changes break adapter', () => {
      const error = new AdapterError(
        'PLATFORM_UPDATED',
        'Netflix player structure has changed',
        'netflix'
      );
      expect(error.code).toBe('PLATFORM_UPDATED');
    });

    it('UNSUPPORTED_CONTENT should be used for incompatible content', () => {
      const error = new AdapterError(
        'UNSUPPORTED_CONTENT',
        'Live streams are not supported',
        'youtube'
      );
      expect(error.code).toBe('UNSUPPORTED_CONTENT');
    });
  });
});
