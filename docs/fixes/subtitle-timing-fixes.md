# 字幕翻譯時間延遲修復紀錄

## 問題描述

用戶反映在使用 AI 翻譯字幕時，翻譯後的字幕會出現時間位移（timing shifts），導致字幕顯示與影片音訊不同步。此問題在以下情況特別明顯：

- 固定字幕翻譯
- 自動生成字幕（ASR）翻譯
- AI 上下文翻譯後的字幕

## 根本原因分析

經過深入調查，發現多個潛在問題：

### 1. 文字匹配導致錯誤的 cue 更新
當多個字幕 cue 具有相同文字時（常見於 ASR 或重複對話），使用文字匹配會找到第一個匹配的 cue，而非正確時間點的 cue。

### 2. 字幕未按時間排序
某些字幕檔案中的 cue 可能不是按時間順序排列，導致線性搜尋 `findActiveCue` 返回錯誤的 cue。

### 3. 顯示狀態追蹤不完整
僅追蹤 `lastDisplayedText` 無法處理連續相同翻譯文字的情況，導致第二個相同文字的 cue 不會觸發更新。

### 4. 狀態重置不一致
在刷新顯示或清除 overlay 時，未同時重置所有追蹤變數。

## 修復方案

### 修復 1: 使用索引匹配作為主要方法
**Commit:** `0058375`

**修改檔案:** `src/content/index.ts`

```typescript
// IMPORTANT: Use index-based matching as PRIMARY method
// The parser reindexes cues so cue.index === array position
const cueIndex = translatedCue.index;
if (cueIndex >= 0 && cueIndex < preTranslatedCuesWithTiming.length) {
  const timingCue = preTranslatedCuesWithTiming[cueIndex];
  // Verify the text matches to avoid mismatched indices
  if (timingCue.originalText.trim() === original) {
    timingCue.translatedText = translated;
    continue;
  }
}

// Fallback to text-based matching only if index matching failed
for (const timingCue of preTranslatedCuesWithTiming) {
  if (timingCue.originalText.trim() === original) {
    timingCue.translatedText = translated;
    break;
  }
}
```

**說明:**
- 改用索引匹配作為主要方法，因為解析器會重新索引使 `cue.index === array position`
- 文字匹配僅作為後備方案

---

### 修復 2: 按時間排序並重新索引
**Commit:** `798fefc`

**修改檔案:** `src/content/index.ts`

```typescript
// IMPORTANT: Sort cues by startTime to ensure correct time-based lookup
// Some subtitle formats may have cues out of order in the file
// After sorting, reindex to maintain the invariant: cue.index === array position
cues = cues.slice().sort((a, b) => a.startTime - b.startTime);
cues = cues.map((cue, idx) => ({ ...cue, index: idx }));
```

**說明:**
- 解析後按 `startTime` 排序確保時間順序
- 排序後重新索引以維持 `cue.index === array position` 不變式
- 快取的翻譯也同樣排序處理

---

### 修復 3: 追蹤顯示的 cue 起始時間
**Commit:** `1fb5110`

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
private lastDisplayedCueStart: number = -1;  // Track which cue is displayed

// Update display if:
// 1. The text has changed, OR
// 2. We're on a different cue (different start time) even if text is the same
const cueChanged = activeCue.startTime !== this.lastDisplayedCueStart;
const textChanged = displayText !== this.lastDisplayedText;

if (textChanged || cueChanged) {
  this.lastDisplayedText = displayText;
  this.lastDisplayedCueStart = activeCue.startTime;
  this.updateOverlay(activeCue.originalText, activeCue.translatedText);
}
```

**說明:**
- 新增 `lastDisplayedCueStart` 追蹤當前顯示的 cue
- 即使翻譯文字相同，切換到不同 cue 時也會觸發更新

---

### 修復 4: 統一重置顯示追蹤變數
**Commits:** `1d4d19a`, `e1b0b57`

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
// refreshCurrentCue()
refreshCurrentCue(): void {
  if (this.state !== 'active' || !this.videoElement) {
    return;
  }
  // Reset display tracking to force re-render
  this.lastDisplayedText = '';
  this.lastDisplayedCueStart = -1;
  this.onTimeUpdateImmediate();
}

// On-demand translation callback
if (this.state === 'active') {
  this.lastDisplayedText = ''; // Force refresh
  this.lastDisplayedCueStart = -1; // Also reset cue tracking
  this.onTimeUpdateImmediate();
}

// Clear overlay
if (this.lastDisplayedText !== '' || this.lastDisplayedCueStart !== -1) {
  this.lastDisplayedText = '';
  this.lastDisplayedCueStart = -1;
  this.clearOverlay();
}
```

**說明:**
- 所有重置顯示狀態的地方都同時重置 `lastDisplayedText` 和 `lastDisplayedCueStart`
- 確保狀態一致性

---

### 先前相關修復

| Commit | 說明 |
|--------|------|
| `d67ca61` | 簡化快取匹配邏輯以防止時間問題 |
| `323111f` | 使用線性搜尋取代二分搜尋以提高可靠性 |
| `36861ad` | 改進字幕翻譯時間以防止延遲和時間位移 |

---

### 修復 5: ASR 字幕片段合併優化
**日期:** 2026-01-24

**新增檔案:** `src/shared/utils/asr-consolidator.ts`

**修改檔案:** `src/content/index.ts`

**問題描述:**
YouTube 自動產生的字幕（ASR）會將語音切分成非常短的片段（通常是單字或短語）。在雙語顯示時，這會導致原文與翻譯對不齊：

```
原本顯示:
00:01.0 "Hello"    → "你好"
00:01.5 "world"    → "世界"
00:02.0 "how"      → "怎麼"
00:02.5 "are you"  → "樣你"   ← 對不齊！
```

**解決方案:**
建立 `smartConsolidateASRCues()` 函數，將碎片化的 ASR 字幕合併成完整句子：

```typescript
import { smartConsolidateASRCues } from '../shared/utils/asr-consolidator';

// 在解析和排序後，對 ASR 字幕進行合併
const originalCueCount = cues.length;
cues = smartConsolidateASRCues(cues, isAutoGenerated ?? false);
if (cues.length !== originalCueCount) {
  log.debug(`[Content] Consolidated ASR cues: ${originalCueCount} → ${cues.length} cues`);
}
```

**合併後顯示:**
```
00:01.0-00:03.0 "Hello world how are you" → "你好世界你好嗎"  ← 對齊！
```

**合併邏輯:**

| 條件 | 預設值 | 說明 |
|------|--------|------|
| `maxGapMs` | 1500ms | 片段間最大時間間隔 |
| `maxDurationMs` | 8000ms | 合併後最大持續時間 |
| `sentenceEndChars` | `.!?。！？` 等 | 句子結束標點符號 |

**智慧判斷:**
只有同時符合以下條件時才會合併：
1. 字幕標記為自動產生 (`isAutoGenerated = true`)
2. 內容確實是碎片化的（平均文字長度 < 20 字元，平均持續時間 < 2 秒）

**整合位置:**
在 `src/content/index.ts` 的三個字幕解析點都加入合併處理：
- 即時翻譯流程 (line ~866)
- 背景翻譯流程 (line ~742)
- 按需下載獲取 (line ~1800)

**測試:** 新增 17 個單元測試於 `tests/unit/utils/asr-consolidator.test.ts`

---

## 技術細節

### 時間保存流程

```
解析器 (JSON3/WebVTT/TTML)
    ↓
排序 (按 startTime)
    ↓
重新索引 (cue.index = array position)
    ↓
preTranslatedCuesWithTiming (保留 startTime/endTime)
    ↓
翻譯匹配 (使用 index)
    ↓
findActiveCue (使用 currentTime 比對 startTime/endTime)
    ↓
顯示 (追蹤 startTime 和 text)
```

### 關鍵不變式

1. **索引對應位置:** `cue.index === array position`
2. **時間保留:** 原始 `startTime` 和 `endTime` 永不修改
3. **時間排序:** cues 陣列始終按 `startTime` 排序

### 受影響的檔案

- `src/content/index.ts` - 翻譯協調和匹配邏輯
- `src/content/realtime-translator.ts` - 即時顯示和狀態追蹤
- `src/shared/parsers/json3-parser.ts` - YouTube JSON3 解析（已移除合併邏輯）
- `src/shared/utils/asr-consolidator.ts` - ASR 字幕片段合併（新增）

---

## 測試驗證

所有 351 個測試通過：

```bash
npm test
# Test Files  15 passed (15)
# Tests  351 passed (351)
```

---

## 版本資訊

- 修復日期: 2026-01-23 ~ 2026-01-24
- 相關 commits: `0058375`, `798fefc`, `1fb5110`, `1d4d19a`, `e1b0b57`
- ASR 合併優化: 2026-01-24

---

## 修復 6: ASR 字幕時間策略與雙層顯示模式
**日期:** 2026-01-24

### 問題描述

YouTube 自動產生的字幕（ASR）是逐字顯示的，當我們把這些碎片合併成完整句子後，時間軸會出現偏移：

```
原本 YouTube 顯示:
00:01.0 "Hello"
00:01.5 "world"
00:02.0 "test"

我們合併後顯示:
00:01.0 "Hello world test" → 整句在第一個字就出現，時間感覺超前
```

### 解決方案

#### 1. 加權時間策略 (Weighted Timing Strategy)

**修改檔案:** `src/shared/utils/asr-consolidator.ts`

新增 `timingStrategy` 選項：

| 策略 | 說明 |
|------|------|
| `first` (預設) | 使用第一個片段的開始時間 |
| `last` | 使用最後一個片段的開始時間（語句說完才顯示） |
| `weighted` | 根據文字長度加權計算時間（推薦用於 ASR） |
| `midpoint` | 使用第一個和最後一個片段的中間時間點 |

```typescript
case 'weighted': {
  // 根據文字長度加權計算開始時間
  let totalWeight = 0;
  let weightedTime = 0;
  for (const cue of currentGroup) {
    const weight = cue.text.trim().length;
    weightedTime += cue.startTime * weight;
    totalWeight += weight;
  }
  startTime = totalWeight > 0 ? Math.round(weightedTime / totalWeight) : firstCue.startTime;
  // 延長結束時間確保足夠閱讀時間
  const remainingAudio = lastCue.endTime - startTime;
  const minDisplayTime = Math.max(2000, remainingAudio + 500);
  endTime = Math.max(lastCue.endTime, startTime + minDisplayTime);
  break;
}
```

**效果:** 合併後的字幕會根據文字分布，在適當的時間點出現，減少「超前顯示」的感覺。

#### 2. 雙層顯示模式 (Dual-Layer Display)

**修改檔案:**
- `src/content/adapters/types.ts` - 新增 `hideNativeSubtitles` 選項
- `src/content/realtime-translator.ts` - 實作雙層顯示定位

新增 `hideNativeSubtitles` 選項到 `RenderOptions`:

```typescript
/**
 * 是否隱藏平台原生字幕
 * - true: 隱藏原生字幕，只顯示我們的雙語 overlay
 * - false: 保留原生字幕，同時顯示翻譯 overlay（位置較高避免重疊）
 */
hideNativeSubtitles?: boolean;  // 預設: true
```

當 `hideNativeSubtitles: false` 時:
- 原生的 YouTube 逐字字幕保持顯示（保留原始時間軸）
- 我們的翻譯 overlay 位置上移（15% from bottom）避免重疊
- 使用者可以同時看到原生進度字幕 + 完整翻譯句子

```css
/* 當原生字幕可見時，將 overlay 上移 */
.ai-subtitle-overlay.ai-subtitle-overlay-above-native {
  bottom: 15%;
}
```

#### 3. 使用者控制

**修改檔案:**
- `src/content/ui/settings-panel.ts` - 新增設定面板控制
- `src/content/index.ts` - 新增鍵盤快捷鍵

| 控制方式 | 功能 |
|---------|------|
| 設定面板 | 「隱藏原生字幕」開關 |
| **Shift + N** | 快速切換原生字幕顯示/隱藏 |
| Shift + ← | 延遲字幕 500ms |
| Shift + → | 提前字幕 500ms |
| Shift + 0 | 重置時間偏移 |

**設定持久化:** 所有設定儲存在 localStorage，重新整理頁面後保留。

### 測試驗證

```bash
npm test
# Test Files  15 passed (15)
# Tests  355 passed (355)   # 新增 4 個時間策略測試
```

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/shared/utils/asr-consolidator.ts` | 新增 `timingStrategy` 選項及實作 |
| `src/content/adapters/types.ts` | 新增 `hideNativeSubtitles` 到 `RenderOptions` |
| `src/content/realtime-translator.ts` | 實作雙層顯示定位及原生字幕控制 |
| `src/content/ui/settings-panel.ts` | 新增設定面板控制項 |
| `src/content/index.ts` | 使用 weighted 策略、新增 Shift+N 快捷鍵 |
| `tests/unit/utils/asr-consolidator.test.ts` | 新增時間策略測試 |

---

## 修復 7: 統一 ASR 字幕時間策略
**日期:** 2026-01-24

### 問題描述

在多個字幕處理位置（即時翻譯、背景翻譯、按需下載）使用不同的時間策略，導致時間軸行為不一致：

| 處理位置 | 原本策略 | 問題 |
|---------|----------|------|
| 即時翻譯 | `weighted` | ✓ 正確 |
| 背景翻譯 | `first` (預設) | 字幕提前顯示 |
| 按需下載 | `first` (預設) | 字幕提前顯示 |

### 解決方案

統一所有 ASR 字幕合併位置使用 `weighted` 時間策略：

**修改檔案:** `src/content/index.ts`

```typescript
// 背景翻譯流程 (原 line ~750)
cues = smartConsolidateASRCues(cues, track.isAutoGenerated, {
  timingStrategy: 'weighted',
});

// 按需下載流程 (原 line ~1833)
parsedCues = smartConsolidateASRCues(parsedCues, track.isAutoGenerated, {
  timingStrategy: 'weighted',
});
```

### 為什麼選擇 `weighted` 策略

`weighted` 策略根據文字長度加權計算開始時間，平衡了「字幕提前顯示」與「字幕延遲顯示」的問題：

```
原始 ASR 片段:
00:01.0 "Hello"     (5 字元)
00:01.5 "world"     (5 字元)
00:02.0 "everyone"  (8 字元)

加權計算: (1000×5 + 1500×5 + 2000×8) / (5+5+8) = 1583ms

結果: 合併字幕在 00:01.583 顯示，而非 00:01.0 (太早) 或 00:02.0 (太晚)
```

### 效果對比

| 策略 | 顯示時間 | 使用者體驗 |
|------|---------|-----------|
| `first` | 00:01.0 | 字幕在說話開始就出現，使用者看到完整句子但音訊還沒講完 |
| `last` | 00:02.0 | 字幕在說話結束才出現，使用者可能錯過一些內容 |
| `weighted` | 00:01.58 | 字幕在句子約 60% 講完時出現，平衡閱讀時間與同步感 |

### 測試驗證

```bash
npm test
# Test Files  15 passed (15)
# Tests  355 passed (355)
```

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/index.ts` | 統一三處 ASR 合併都使用 `weighted` 時間策略 |

---

## 修復 8: 字幕間隙平滑處理
**日期:** 2026-01-24

### 問題描述

ASR 字幕在合併後，某些字幕之間可能存在短暫的時間間隙。當影片播放到這些間隙時，字幕會突然消失再出現，造成「閃爍」效果，影響觀看體驗。

```
時間軸示意:
|--Cue 1--|   間隙   |--Cue 2--|
0:01.0   0:02.0   0:02.3   0:03.5

在 0:02.0~0:02.3 之間，字幕會消失
```

### 解決方案

在 `findActiveCue` 函數中新增「寬限期」(grace period) 機制：

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
private findActiveCue(cues: TranslatedCue[], currentTime: number): TranslatedCue | null {
  // 第一次搜尋：找精確匹配
  for (const cue of cues) {
    if (currentTime >= cue.startTime && currentTime < cue.endTime) {
      return cue;
    }
  }

  // 第二次搜尋：處理字幕間隙
  const GAP_GRACE_PERIOD_MS = 500; // 延長前一個字幕顯示最多 500ms

  for (let i = 0; i < cues.length - 1; i++) {
    const currentCue = cues[i];
    const nextCue = cues[i + 1];
    const gapStart = currentCue.endTime;
    const gapEnd = nextCue.startTime;

    if (currentTime >= gapStart && currentTime < gapEnd) {
      const gapDuration = gapEnd - gapStart;
      const timeIntoGap = currentTime - gapStart;

      // 如果間隙較小且在寬限期內，繼續顯示前一個字幕
      if (gapDuration <= GAP_GRACE_PERIOD_MS * 2 && timeIntoGap <= GAP_GRACE_PERIOD_MS) {
        return currentCue;
      }
      break;
    }
  }

  return null;
}
```

### 效果對比

| 情境 | 修復前 | 修復後 |
|------|--------|--------|
| 300ms 間隙 | 字幕閃爍消失 | 前一字幕延長顯示 |
| 800ms 間隙 | 字幕消失較長 | 前 500ms 延長顯示，後 300ms 自然過渡 |
| 2000ms 間隙 | 字幕消失 | 字幕消失（正常行為） |

### 設計原則

1. **短間隙（≤500ms）**：延長前一字幕顯示，避免閃爍
2. **中等間隙（500ms~1000ms）**：前半延長顯示，後半自然過渡到下一字幕
3. **長間隙（>1000ms）**：正常消失，表示說話者停頓或場景切換

### 測試驗證

```bash
npm test
# Test Files  16 passed (16)
# Tests  367 passed (367)
```

新增 12 個單元測試驗證間隙處理邏輯：
- 精確時間匹配測試（6 個）
- 間隙寬限期處理測試（4 個）
- ASR 字幕場景測試（2 個）

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/realtime-translator.ts` | 新增間隙寬限期處理邏輯 |
| `tests/unit/content/realtime-translator.test.ts` | 新增間隙處理單元測試 |

---

## 修復總覽

下表總結了所有 ASR 字幕時間對齊相關的修復：

| 編號 | 修復名稱 | 問題 | 解決方案 | 主要檔案 |
|------|---------|------|---------|---------|
| 1 | 索引匹配 | 相同文字匹配錯誤 cue | 使用索引而非文字匹配 | `index.ts` |
| 2 | 時間排序 | cue 未按時間排序 | 排序後重新索引 | `index.ts` |
| 3 | Cue 追蹤 | 相同文字不更新顯示 | 追蹤 startTime | `realtime-translator.ts` |
| 4 | 狀態重置 | 重置不完整 | 統一重置邏輯 | `realtime-translator.ts` |
| 5 | ASR 合併 | 碎片化字幕對不齊 | 智慧合併成句子 | `asr-consolidator.ts` |
| 6 | 時間策略 | 合併後時間偏移 | 四種時間策略 | `asr-consolidator.ts` |
| 7 | 策略統一 | 不同流程用不同策略 | 統一用 `weighted` | `index.ts` |
| 8 | 間隙處理 | 字幕閃爍 | 500ms 寬限期 | `realtime-translator.ts` |

### 關鍵設計決策

1. **時間策略選擇 `weighted`**：根據文字長度加權計算顯示時間，平衡「提前顯示」與「延遲顯示」

2. **間隙寬限期 500ms**：在小於 1 秒的間隙中，延長前一字幕顯示以避免閃爍

3. **索引優先匹配**：使用 `cue.index === array position` 不變式確保翻譯匹配正確

### 測試覆蓋

- 總測試數：367 個
- ASR 合併測試：21 個
- 間隙處理測試：12 個
- 解析器測試：82 個
