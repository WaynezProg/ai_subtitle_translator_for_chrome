# 字幕翻譯時間延遲修復紀錄

## 問題描述

用戶反映在使用 AI 翻譯字幕時，翻譯後的字幕會出現時間位移（timing shifts），導致字幕顯示與影片音訊不同步。此問題在以下情況特別明顯：

- 固定字幕翻譯
- 自動生成字幕（ASR）翻譯
- AI 上下文翻譯後的字幕

## 根本原因分析

經過深入調查，發現多個潛在問題：

### 1. 文字匹配導致錯誤的 cue 更新
當多個字幕 cue 具有相同文字時（常見於 ASR 或重複對話），使用文字匹配會找到第一個匹配的 cue，而非正確時間點的 cue。

### 2. 字幕未按時間排序
某些字幕檔案中的 cue 可能不是按時間順序排列，導致線性搜尋 `findActiveCue` 返回錯誤的 cue。

### 3. 顯示狀態追蹤不完整
僅追蹤 `lastDisplayedText` 無法處理連續相同翻譯文字的情況，導致第二個相同文字的 cue 不會觸發更新。

### 4. 狀態重置不一致
在刷新顯示或清除 overlay 時，未同時重置所有追蹤變數。

## 修復方案

### 修復 1: 使用索引匹配作為主要方法
**Commit:** `0058375`

**修改檔案:** `src/content/index.ts`

```typescript
// IMPORTANT: Use index-based matching as PRIMARY method
// The parser reindexes cues so cue.index === array position
const cueIndex = translatedCue.index;
if (cueIndex >= 0 && cueIndex < preTranslatedCuesWithTiming.length) {
  const timingCue = preTranslatedCuesWithTiming[cueIndex];
  // Verify the text matches to avoid mismatched indices
  if (timingCue.originalText.trim() === original) {
    timingCue.translatedText = translated;
    continue;
  }
}

// Fallback to text-based matching only if index matching failed
for (const timingCue of preTranslatedCuesWithTiming) {
  if (timingCue.originalText.trim() === original) {
    timingCue.translatedText = translated;
    break;
  }
}
```

**說明:**
- 改用索引匹配作為主要方法，因為解析器會重新索引使 `cue.index === array position`
- 文字匹配僅作為後備方案

---

### 修復 2: 按時間排序並重新索引
**Commit:** `798fefc`

**修改檔案:** `src/content/index.ts`

```typescript
// IMPORTANT: Sort cues by startTime to ensure correct time-based lookup
// Some subtitle formats may have cues out of order in the file
// After sorting, reindex to maintain the invariant: cue.index === array position
cues = cues.slice().sort((a, b) => a.startTime - b.startTime);
cues = cues.map((cue, idx) => ({ ...cue, index: idx }));
```

**說明:**
- 解析後按 `startTime` 排序確保時間順序
- 排序後重新索引以維持 `cue.index === array position` 不變式
- 快取的翻譯也同樣排序處理

---

### 修復 3: 追蹤顯示的 cue 起始時間
**Commit:** `1fb5110`

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
private lastDisplayedCueStart: number = -1;  // Track which cue is displayed

// Update display if:
// 1. The text has changed, OR
// 2. We're on a different cue (different start time) even if text is the same
const cueChanged = activeCue.startTime !== this.lastDisplayedCueStart;
const textChanged = displayText !== this.lastDisplayedText;

if (textChanged || cueChanged) {
  this.lastDisplayedText = displayText;
  this.lastDisplayedCueStart = activeCue.startTime;
  this.updateOverlay(activeCue.originalText, activeCue.translatedText);
}
```

**說明:**
- 新增 `lastDisplayedCueStart` 追蹤當前顯示的 cue
- 即使翻譯文字相同，切換到不同 cue 時也會觸發更新

---

### 修復 4: 統一重置顯示追蹤變數
**Commits:** `1d4d19a`, `e1b0b57`

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
// refreshCurrentCue()
refreshCurrentCue(): void {
  if (this.state !== 'active' || !this.videoElement) {
    return;
  }
  // Reset display tracking to force re-render
  this.lastDisplayedText = '';
  this.lastDisplayedCueStart = -1;
  this.onTimeUpdateImmediate();
}

// On-demand translation callback
if (this.state === 'active') {
  this.lastDisplayedText = ''; // Force refresh
  this.lastDisplayedCueStart = -1; // Also reset cue tracking
  this.onTimeUpdateImmediate();
}

// Clear overlay
if (this.lastDisplayedText !== '' || this.lastDisplayedCueStart !== -1) {
  this.lastDisplayedText = '';
  this.lastDisplayedCueStart = -1;
  this.clearOverlay();
}
```

**說明:**
- 所有重置顯示狀態的地方都同時重置 `lastDisplayedText` 和 `lastDisplayedCueStart`
- 確保狀態一致性

---

### 先前相關修復

| Commit | 說明 |
|--------|------|
| `d67ca61` | 簡化快取匹配邏輯以防止時間問題 |
| `323111f` | 使用線性搜尋取代二分搜尋以提高可靠性 |
| `36861ad` | 改進字幕翻譯時間以防止延遲和時間位移 |

---

### 修復 5: ASR 字幕片段合併優化
**日期:** 2026-01-24

**新增檔案:** `src/shared/utils/asr-consolidator.ts`

**修改檔案:** `src/content/index.ts`

**問題描述:**
YouTube 自動產生的字幕（ASR）會將語音切分成非常短的片段（通常是單字或短語）。在雙語顯示時，這會導致原文與翻譯對不齊：

```
原本顯示:
00:01.0 "Hello"    → "你好"
00:01.5 "world"    → "世界"
00:02.0 "how"      → "怎麼"
00:02.5 "are you"  → "樣你"   ← 對不齊！
```

**解決方案:**
建立 `smartConsolidateASRCues()` 函數，將碎片化的 ASR 字幕合併成完整句子：

```typescript
import { smartConsolidateASRCues } from '../shared/utils/asr-consolidator';

// 在解析和排序後，對 ASR 字幕進行合併
const originalCueCount = cues.length;
cues = smartConsolidateASRCues(cues, isAutoGenerated ?? false);
if (cues.length !== originalCueCount) {
  log.debug(`[Content] Consolidated ASR cues: ${originalCueCount} → ${cues.length} cues`);
}
```

**合併後顯示:**
```
00:01.0-00:03.0 "Hello world how are you" → "你好世界你好嗎"  ← 對齊！
```

**合併邏輯:**

| 條件 | 預設值 | 說明 |
|------|--------|------|
| `maxGapMs` | 1500ms | 片段間最大時間間隔 |
| `maxDurationMs` | 8000ms | 合併後最大持續時間 |
| `sentenceEndChars` | `.!?。！？` 等 | 句子結束標點符號 |

**智慧判斷:**
只有同時符合以下條件時才會合併：
1. 字幕標記為自動產生 (`isAutoGenerated = true`)
2. 內容確實是碎片化的（平均文字長度 < 20 字元，平均持續時間 < 2 秒）

**整合位置:**
在 `src/content/index.ts` 的三個字幕解析點都加入合併處理：
- 即時翻譯流程 (line ~866)
- 背景翻譯流程 (line ~742)
- 按需下載獲取 (line ~1800)

**測試:** 新增 17 個單元測試於 `tests/unit/utils/asr-consolidator.test.ts`

---

## 技術細節

### 時間保存流程

```
解析器 (JSON3/WebVTT/TTML)
    ↓
排序 (按 startTime)
    ↓
重新索引 (cue.index = array position)
    ↓
preTranslatedCuesWithTiming (保留 startTime/endTime)
    ↓
翻譯匹配 (使用 index)
    ↓
findActiveCue (使用 currentTime 比對 startTime/endTime)
    ↓
顯示 (追蹤 startTime 和 text)
```

### 關鍵不變式

1. **索引對應位置:** `cue.index === array position`
2. **時間保留:** 原始 `startTime` 和 `endTime` 永不修改
3. **時間排序:** cues 陣列始終按 `startTime` 排序

### 受影響的檔案

- `src/content/index.ts` - 翻譯協調和匹配邏輯
- `src/content/realtime-translator.ts` - 即時顯示和狀態追蹤
- `src/shared/parsers/json3-parser.ts` - YouTube JSON3 解析（已移除合併邏輯）
- `src/shared/utils/asr-consolidator.ts` - ASR 字幕片段合併（新增）

---

## 測試驗證

所有 351 個測試通過：

```bash
npm test
# Test Files  15 passed (15)
# Tests  351 passed (351)
```

---

## 版本資訊

- 修復日期: 2026-01-23 ~ 2026-01-24
- 相關 commits: `0058375`, `798fefc`, `1fb5110`, `1d4d19a`, `e1b0b57`
- ASR 合併優化: 2026-01-24

---

## 修復 6: ASR 字幕時間策略與雙層顯示模式
**日期:** 2026-01-24

### 問題描述

YouTube 自動產生的字幕（ASR）是逐字顯示的，當我們把這些碎片合併成完整句子後，時間軸會出現偏移：

```
原本 YouTube 顯示:
00:01.0 "Hello"
00:01.5 "world"
00:02.0 "test"

我們合併後顯示:
00:01.0 "Hello world test" → 整句在第一個字就出現，時間感覺超前
```

### 解決方案

#### 1. 加權時間策略 (Weighted Timing Strategy)

**修改檔案:** `src/shared/utils/asr-consolidator.ts`

新增 `timingStrategy` 選項：

| 策略 | 說明 |
|------|------|
| `first` (預設) | 使用第一個片段的開始時間 |
| `last` | 使用最後一個片段的開始時間（語句說完才顯示） |
| `weighted` | 根據文字長度加權計算時間（推薦用於 ASR） |
| `midpoint` | 使用第一個和最後一個片段的中間時間點 |

```typescript
case 'weighted': {
  // 根據文字長度加權計算開始時間
  let totalWeight = 0;
  let weightedTime = 0;
  for (const cue of currentGroup) {
    const weight = cue.text.trim().length;
    weightedTime += cue.startTime * weight;
    totalWeight += weight;
  }
  startTime = totalWeight > 0 ? Math.round(weightedTime / totalWeight) : firstCue.startTime;
  // 延長結束時間確保足夠閱讀時間
  const remainingAudio = lastCue.endTime - startTime;
  const minDisplayTime = Math.max(2000, remainingAudio + 500);
  endTime = Math.max(lastCue.endTime, startTime + minDisplayTime);
  break;
}
```

**效果:** 合併後的字幕會根據文字分布，在適當的時間點出現，減少「超前顯示」的感覺。

#### 2. 雙層顯示模式 (Dual-Layer Display)

**修改檔案:**
- `src/content/adapters/types.ts` - 新增 `hideNativeSubtitles` 選項
- `src/content/realtime-translator.ts` - 實作雙層顯示定位

新增 `hideNativeSubtitles` 選項到 `RenderOptions`:

```typescript
/**
 * 是否隱藏平台原生字幕
 * - true: 隱藏原生字幕，只顯示我們的雙語 overlay
 * - false: 保留原生字幕，同時顯示翻譯 overlay（位置較高避免重疊）
 */
hideNativeSubtitles?: boolean;  // 預設: true
```

當 `hideNativeSubtitles: false` 時:
- 原生的 YouTube 逐字字幕保持顯示（保留原始時間軸）
- 我們的翻譯 overlay 位置上移（15% from bottom）避免重疊
- 使用者可以同時看到原生進度字幕 + 完整翻譯句子

```css
/* 當原生字幕可見時，將 overlay 上移 */
.ai-subtitle-overlay.ai-subtitle-overlay-above-native {
  bottom: 15%;
}
```

#### 3. 使用者控制

**修改檔案:**
- `src/content/ui/settings-panel.ts` - 新增設定面板控制
- `src/content/index.ts` - 新增鍵盤快捷鍵

| 控制方式 | 功能 |
|---------|------|
| 設定面板 | 「隱藏原生字幕」開關 |
| **Shift + N** | 快速切換原生字幕顯示/隱藏 |
| Shift + ← | 延遲字幕 500ms |
| Shift + → | 提前字幕 500ms |
| Shift + 0 | 重置時間偏移 |

**設定持久化:** 所有設定儲存在 localStorage，重新整理頁面後保留。

### 測試驗證

```bash
npm test
# Test Files  15 passed (15)
# Tests  355 passed (355)   # 新增 4 個時間策略測試
```

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/shared/utils/asr-consolidator.ts` | 新增 `timingStrategy` 選項及實作 |
| `src/content/adapters/types.ts` | 新增 `hideNativeSubtitles` 到 `RenderOptions` |
| `src/content/realtime-translator.ts` | 實作雙層顯示定位及原生字幕控制 |
| `src/content/ui/settings-panel.ts` | 新增設定面板控制項 |
| `src/content/index.ts` | 使用 weighted 策略、新增 Shift+N 快捷鍵 |
| `tests/unit/utils/asr-consolidator.test.ts` | 新增時間策略測試 |

---

## 修復 7: 改回使用 `first` 時間策略
**日期:** 2026-01-24

### 問題描述

經過進一步分析和用戶反饋，`weighted` 時間策略導致翻譯字幕顯示得比原始語音晚，造成「時間位移」的感覺：

```
原始 ASR 片段:
00:01.0 "Hello"     (5 字元)
00:01.5 "world"     (5 字元)
00:02.0 "everyone"  (8 字元)

weighted 計算: (1000×5 + 1500×5 + 2000×8) / (5+5+8) = 1583ms

問題: 翻譯在 00:01.583 才顯示，但說話者在 00:01.0 就開始說了！
使用者會感覺翻譯「延遲」了約 583ms。
```

### 解決方案

**改回使用 `first` 策略（現在是預設）**

統一所有 ASR 字幕合併位置使用預設的 `first` 時間策略：

**修改檔案:** `src/content/index.ts`

```typescript
// 所有字幕處理流程現在使用預設的 'first' 策略
cues = smartConsolidateASRCues(cues, track.isAutoGenerated);
// 不再傳入 { timingStrategy: 'weighted' }
```

### 為什麼改回 `first` 策略

1. **符合使用者預期**：使用者期望翻譯在說話者「開始說話」時就出現
2. **可以先讀後聽**：讓觀眾在聽到原文的同時閱讀翻譯
3. **減少感知延遲**：`weighted` 策略的「平衡」實際上造成了感知上的延遲

### 策略對比

| 策略 | 顯示時間 | 使用者體驗 |
|------|---------|-----------|
| **`first` (推薦)** | 00:01.0 | ✓ 翻譯在語音開始時就出現，可以邊讀邊聽 |
| `weighted` | 00:01.58 | ✗ 翻譯延遲，感覺不同步 |
| `last` | 00:02.0 | ✗ 翻譯太晚，錯過內容 |

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/shared/utils/asr-consolidator.ts` | 更新預設策略說明，確認 `first` 為預設 |
| `src/content/index.ts` | 移除 `{ timingStrategy: 'weighted' }`，使用預設策略 |

---

## 修復 8: 智能間隙平滑處理
**日期:** 2026-01-24

### 問題描述

ASR 字幕在合併後，某些字幕之間可能存在短暫的時間間隙。當影片播放到這些間隙時，字幕會突然消失再出現，造成「閃爍」效果，影響觀看體驗。

```
時間軸示意:
|--Cue 1--|   間隙   |--Cue 2--|
0:01.0   0:02.0   0:02.3   0:03.5

在 0:02.0~0:02.3 之間，字幕會消失
```

### 解決方案

在 `findActiveCue` 函數中新增「智能寬限期」(intelligent grace period) 機制：

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
private findActiveCue(cues: TranslatedCue[], currentTime: number): TranslatedCue | null {
  // 第一次搜尋：找精確匹配
  for (const cue of cues) {
    if (currentTime >= cue.startTime && currentTime < cue.endTime) {
      return cue;
    }
  }

  // 第二次搜尋：智能處理字幕間隙
  for (let i = 0; i < cues.length - 1; i++) {
    const currentCue = cues[i];
    const nextCue = cues[i + 1];
    const gapStart = currentCue.endTime;
    const gapEnd = nextCue.startTime;

    if (currentTime >= gapStart && currentTime < gapEnd) {
      const gapDuration = gapEnd - gapStart;
      const timeIntoGap = currentTime - gapStart;

      // 根據間隙長度決定寬限期
      // 短間隙（句子內暫停）→ 較長寬限期
      // 長間隙（句子邊界）→ 較短寬限期
      let gracePeriod: number;
      if (gapDuration <= 1000) {
        gracePeriod = 500;  // 短間隙：延長 500ms
      } else if (gapDuration <= 2000) {
        gracePeriod = 300;  // 中等間隙：延長 300ms
      } else {
        gracePeriod = 0;    // 長間隙：不延長（自然停頓）
      }

      if (gracePeriod > 0 && timeIntoGap <= gracePeriod) {
        return currentCue;
      }
      break;
    }
  }

  return null;
}
```

### 效果對比（智能版）

| 間隙長度 | 寬限期 | 行為 | 原因 |
|----------|--------|------|------|
| ≤1000ms（短） | 500ms | 前一字幕延長顯示 | 可能是句子內的短暫停頓 |
| 1000-2000ms（中） | 300ms | 前一字幕短暫延長 | 可能是句子邊界 |
| >2000ms（長） | 0ms | 字幕消失 | 明確的場景切換或停頓 |

### 設計原則

1. **智能判斷**：根據間隙長度動態調整寬限期
2. **短間隙（≤1000ms）**：通常是 ASR 合併後的句子內停頓，延長 500ms 避免閃爍
3. **中等間隙（1000-2000ms）**：可能是句子邊界，短暫延長 300ms 作為過渡
4. **長間隙（>2000ms）**：明確的停頓或場景切換，正常消失

### 測試驗證

```bash
npm test
# Test Files  16 passed (16)
# Tests  367 passed (367)
```

新增 12 個單元測試驗證間隙處理邏輯：
- 精確時間匹配測試（6 個）
- 間隙寬限期處理測試（4 個）
- ASR 字幕場景測試（2 個）

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/realtime-translator.ts` | 新增智能間隙寬限期處理邏輯 |
| `src/content/subtitle-renderer.ts` | 同步新增智能間隙寬限期處理邏輯 |
| `tests/unit/content/realtime-translator.test.ts` | 新增間隙處理單元測試 |

---

## 修復總覽

下表總結了所有 ASR 字幕時間對齊相關的修復：

| 編號 | 修復名稱 | 問題 | 解決方案 | 主要檔案 |
|------|---------|------|---------|---------|
| 1 | 索引匹配 | 相同文字匹配錯誤 cue | 使用索引而非文字匹配 | `index.ts` |
| 2 | 時間排序 | cue 未按時間排序 | 排序後重新索引 | `index.ts` |
| 3 | Cue 追蹤 | 相同文字不更新顯示 | 追蹤 startTime | `realtime-translator.ts` |
| 4 | 狀態重置 | 重置不完整 | 統一重置邏輯 | `realtime-translator.ts` |
| 5 | ASR 合併 | 碎片化字幕對不齊 | 智慧合併成句子 | `asr-consolidator.ts` |
| 6 | 時間策略 | 合併後時間偏移 | 四種時間策略（可選） | `asr-consolidator.ts` |
| 7 | 策略優化 | `weighted` 造成延遲 | 改回使用 `first` 策略 | `index.ts` |
| 8 | 智能間隙處理 | 字幕閃爍 | 根據間隙長度動態調整寬限期 | `realtime-translator.ts` |

### 關鍵設計決策

1. **時間策略選擇 `first`（預設）**：翻譯在說話者開始說話時立即顯示，讓觀眾可以邊讀邊聽。這比 `weighted` 策略更符合使用者預期，避免感知上的延遲。

2. **智能間隙寬限期**：根據間隙長度動態調整：
   - 短間隙（≤1000ms）：延長 500ms（句子內停頓）
   - 中等間隙（1000-2000ms）：延長 300ms（句子邊界）
   - 長間隙（>2000ms）：不延長（場景切換）

3. **索引優先匹配**：使用 `cue.index === array position` 不變式確保翻譯匹配正確

### 時間策略比較

| 策略 | 適用場景 | 優點 | 缺點 |
|------|---------|------|------|
| **`first` (推薦)** | 即時翻譯、ASR | 同步感最好 | 字幕出現時語音還沒講完 |
| `weighted` | 特殊需求 | 時間點較平衡 | 感知上有延遲 |
| `last` | 特殊需求 | 語音講完才顯示 | 太晚，錯過內容 |
| `midpoint` | 特殊需求 | 折衷方案 | 不夠自然 |

### 測試覆蓋

- 總測試數：379 個
- ASR 合併測試：21 個
- 間隙處理測試：13 個（更新以測試智能間隙處理）
- 時間策略測試：4 個
- 漸進式顯示測試：9 個
- 解析器測試：82 個

---

## 修復 9: ASR 字幕漸進式顯示
**日期:** 2026-01-25

### 問題描述

YouTube 的 ASR 字幕是「逐字累積顯示」的：
```
YouTube 原生顯示:
00:01.0 "Hello"
00:01.5 "Hello world"
00:02.0 "Hello world test"
```

而我們的翻譯是「整句立即顯示」：
```
我們的翻譯顯示:
00:01.0 "你好世界測試"  ← 整句在第一時間就出現
```

這會讓使用者感覺翻譯「跑太前面」，造成時間位移的感覺。

### 解決方案

**漸進式翻譯顯示 (Progressive Reveal)**

新增 `progressiveReveal` 選項，讓翻譯文字根據 cue 的播放進度逐漸顯示，模擬 YouTube 的逐字顯示效果。

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
interface RealtimeTranslatorOptions {
  // ... 其他選項
  /**
   * Enable progressive text reveal for ASR subtitles.
   * When enabled, translated text is revealed character by character based on timing,
   * reducing the "time shift" perception when compared to YouTube's progressive ASR display.
   * Default: true for ASR subtitles, false for manual subtitles
   */
  progressiveReveal?: boolean;
}
```

**漸進式顯示策略:**

| 時間進度 | 顯示文字比例 | 說明 |
|---------|------------|------|
| 0-10% | 0-30% | 快速開始，提供即時上下文 |
| 10-90% | 30-100% | 線性增長 |
| 90-100% | 100% | 完整顯示 |

**計算公式:**

```typescript
private calculateProgressiveReveal(cue: TranslatedCue, currentTime: number) {
  const progress = (currentTime - cue.startTime) / (cue.endTime - cue.startTime);

  let revealRatio: number;
  if (progress <= 0.1) {
    // 快速開始：10% 時間內顯示 30% 文字
    revealRatio = 0.3 * (progress / 0.1);
  } else if (progress >= 0.9) {
    // 結束：完整顯示
    revealRatio = 1;
  } else {
    // 中間：線性增長
    const middleProgress = (progress - 0.1) / 0.8;
    revealRatio = 0.3 + (0.7 * middleProgress);
  }

  return revealRatio;
}
```

**文字顯示處理:**

- **中日韓文字 (CJK):** 逐字顯示
- **拉丁文字:** 優先在單詞邊界處切割

```typescript
private revealTextProgressively(text: string, targetLength: number): string {
  // CJK 文字直接截斷
  if (hasCJK) {
    return text.substring(0, targetLength);
  }

  // 拉丁文字優先在單詞邊界切割
  const words = text.split(/(\s+)/);
  // ... 在單詞邊界處切割
}
```

### 效果對比

**修復前:**
```
時間軸:
00:01.0 ─────────────────────────────────
        "你好世界這是一個測試" (整句立即出現)
```

**修復後:**
```
時間軸:
00:01.0 ─────────────────────────────────
        "你好"                (10% 時)
        "你好世界"            (25% 時)
        "你好世界這是"        (50% 時)
        "你好世界這是一個"    (75% 時)
        "你好世界這是一個測試" (90% 時)
```

### 預設行為

- **ASR 字幕 (`isAutoGenerated: true`):** 預設啟用漸進式顯示
- **手動字幕:** 預設關閉（立即顯示完整翻譯）

可透過 `progressiveReveal` 選項手動覆蓋預設行為。

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/realtime-translator.ts` | 新增漸進式顯示邏輯 |
| `tests/unit/content/realtime-translator.test.ts` | 新增 9 個測試案例 |
| `docs/fixes/subtitle-timing-fixes.md` | 更新文檔 |

### 測試驗證

```bash
npm test
# Test Files  16 passed (16)
# Tests  379 passed (379)   # 新增 9 個漸進式顯示測試
```

---

## 修復 10: 漸進式顯示條件檢查修正
**日期:** 2026-01-25

### 問題描述

漸進式顯示功能的執行邏輯有多餘的檢查，導致即使明確設定 `progressiveReveal: true`，非 ASR 字幕也無法使用此功能。

**問題程式碼:**
```typescript
// 初始化（正確）
this.progressiveRevealEnabled = options.progressiveReveal ?? (options.isAutoGenerated ?? false);

// 執行時（錯誤 - 多餘檢查）
if (this.progressiveRevealEnabled && this.options.isAutoGenerated) {  // ← 這裡多檢查了 isAutoGenerated
```

### 解決方案

移除執行邏輯中多餘的 `isAutoGenerated` 檢查，因為 `progressiveRevealEnabled` 已經在初始化時處理了這個邏輯。

**修正後:**
```typescript
if (this.progressiveRevealEnabled) {
  // 漸進式顯示邏輯
}
```

### 影響

- 使用者現在可以透過 `progressiveReveal: true` 為任何字幕類型啟用漸進式顯示
- ASR 字幕仍然預設啟用（保持原有行為）
- 手動字幕仍然預設關閉（保持原有行為）

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/realtime-translator.ts` | 移除第 496 行多餘的 `&& this.options.isAutoGenerated` 檢查 |

---

## 修復 11: 進階 YouTube ASR 字幕優化
**日期:** 2026-01-25
**Commit:** `6f6c3e0`

### 問題描述

YouTube 自動產生的字幕會「逐字彈出」，而翻譯後的字幕是整句顯示，這會造成「時間差」的感覺。雖然已有漸進式顯示功能，但參數設定需要進一步優化以更好地匹配 YouTube 的顯示節奏。

### 解決方案

#### 1. 優化 Progressive Reveal 策略

**修改檔案:** `src/content/realtime-translator.ts`

```typescript
// 優化後的漸進式顯示策略
// - 0-5% 時間: 顯示 40% 文字（快速啟動減少延遲感）
// - 5-80% 時間: 線性增長到 95%（穩定進展）
// - 80-100% 時間: 完整顯示（確保閱讀完整性）

let revealRatio: number;
if (progress <= 0.05) {
  // 快速啟動：5% 時間內顯示 40% 文字
  revealRatio = 0.4 * (progress / 0.05);
} else if (progress >= 0.8) {
  // 提早完成：80% 時間點就顯示完整
  revealRatio = 1;
} else {
  // 中間：線性增長 40% → 95%
  const middleProgress = (progress - 0.05) / 0.75;
  revealRatio = 0.4 + (0.55 * middleProgress);
}

// 短字幕（< 1 秒）直接完整顯示
if (duration < 1000) {
  return { revealedTranslation: fullTranslation, revealedOriginal: fullOriginal };
}
```

**效果對比:**

| 時間進度 | 修復前 | 修復後 |
|---------|--------|--------|
| 5% | 15% 文字 | 40% 文字 |
| 10% | 30% 文字 | 47% 文字 |
| 50% | 65% 文字 | 73% 文字 |
| 80% | 82% 文字 | 100% 文字 |
| 90% | 100% 文字 | 100% 文字 |

#### 2. 優化 ASR 整合參數

**修改檔案:** `src/shared/utils/asr-consolidator.ts`

| 參數 | 修復前 | 修復後 | 說明 |
|------|--------|--------|------|
| `maxGapMs` | 1500ms | 1200ms | 更自然的句子斷點 |
| `maxDurationMs` | 8000ms | 6000ms | 更短句子，更好時間對齊 |
| `sentenceEndChars` | `.!?。！？…；;` | 新增 `,` 和 `，` | 逗號也可作為斷點 |

#### 3. 優化智能間隙處理

**修改檔案:** `src/content/realtime-translator.ts`, `src/content/subtitle-renderer.ts`

| 間隙長度 | 修復前寬限期 | 修復後寬限期 | 說明 |
|----------|-------------|-------------|------|
| ≤500ms | - | 400ms | 新增：近乎無縫過渡 |
| 500-1000ms | 500ms | 350ms | 調整：短間隙 |
| 1000-1500ms | - | 250ms | 新增：中等間隙 |
| 1000-2000ms | 300ms | - | 移除（由上述取代）|
| >1500ms | - | 0ms | 長間隙不延伸 |
| >2000ms | 0ms | - | 移除（由上述取代）|

### 設計原則

1. **快速啟動**: 在 5% 時間內就顯示 40% 文字，減少初始「延遲感」
2. **提早完成**: 在 80% 時間點就完整顯示，確保使用者有足夠閱讀時間
3. **更細緻的間隙處理**: 新增 ≤500ms 的極短間隙處理，更適合 YouTube ASR
4. **更短的句子合併**: 6 秒上限比 8 秒更容易達到好的時間對齊

### 測試驗證

```bash
npm run typecheck  # 通過
npm run test:unit  # 379 測試全數通過
```

### 相關檔案修改

| 檔案 | 變更 |
|------|------|
| `src/content/realtime-translator.ts` | 優化 Progressive Reveal 策略和 Gap Handling |
| `src/content/subtitle-renderer.ts` | 同步優化 Gap Handling |
| `src/shared/utils/asr-consolidator.ts` | 優化合併參數 |
| `CLAUDE.md` | 新增 ASR 優化文檔 |

---

## 修復 12: 明確指定繁體/簡體中文翻譯
**日期:** 2026-01-25

### 問題描述

翻譯 prompt 中使用語言代碼（如 `zh-TW`）而非完整語言名稱，可能導致 AI 模型無法正確區分繁體中文和簡體中文。

### 解決方案

更新 `getLanguageDisplayName()` 函數，對中文語言代碼返回明確的語言名稱：

**修改檔案:** `src/shared/utils/helpers.ts`

```typescript
export function getLanguageDisplayName(code: string): string {
  // 特別處理中文以確保正確的字體變體
  if (code === 'zh-TW') return 'Traditional Chinese (繁體中文)';
  if (code === 'zh-CN') return 'Simplified Chinese (简体中文)';

  try {
    const displayName = new Intl.DisplayNames(['en'], { type: 'language' });
    return displayName.of(code) || code;
  } catch {
    return code;
  }
}
```

### 更新的 Provider

所有翻譯 provider 的 prompt 現在使用完整語言名稱：

| Provider | 修改檔案 |
|----------|---------|
| Claude API | `src/shared/providers/claude-api-provider.ts` |
| OpenAI API | `src/shared/providers/openai-api-provider.ts` |
| Ollama | `src/shared/providers/ollama-provider.ts` |
| Claude OAuth | `src/shared/providers/claude-oauth-provider.ts` |
| Claude Subscription | `src/shared/providers/claude-subscription-provider.ts` |
| ChatGPT OAuth | `src/shared/providers/chatgpt-oauth-provider.ts` |
| ChatGPT Subscription | `src/shared/providers/chatgpt-subscription-provider.ts` |

### Prompt 範例

**修復前:**
```
Translate subtitle lines from zh-TW to en.
```

**修復後:**
```
Translate subtitle lines from Traditional Chinese (繁體中文) to English (English).
```

### 測試驗證

```bash
npm run typecheck  # 通過
npm run test:unit  # 379 測試全數通過
```
