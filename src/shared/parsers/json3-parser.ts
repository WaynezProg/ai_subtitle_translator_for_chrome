/**
 * JSON3 Parser
 * 
 * Parses YouTube's JSON3 subtitle format (timedtext API response).
 * This is a proprietary format used by YouTube for captions.
 * 
 * ASR (Auto-generated) subtitles have different timing characteristics:
 * - They are generated in near real-time as speech is detected
 * - Segments are shorter and more frequent
 * - Timing should be preserved to maintain sync with audio
 */

import type { Cue } from '../types/subtitle';

/**
 * JSON3 parsing options
 */
export interface JSON3ParseOptions {
  /** 
   * Whether the subtitle is auto-generated (ASR).
   * When true, uses ASR-specific parsing that preserves original timing.
   */
  isAutoGenerated?: boolean;
}

/**
 * JSON3 parsing result
 */
export interface JSON3ParseResult {
  cues: Cue[];
  metadata: {
    /** Original events array length */
    eventCount: number;
    /** Whether the captions are auto-generated (ASR) */
    isAutoGenerated?: boolean;
    /** Language code from the response */
    languageCode?: string;
  };
}

/**
 * JSON3 parsing error
 */
export class JSON3ParseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'JSON3ParseError';
  }
}

/**
 * YouTube JSON3 event structure
 */
interface JSON3Event {
  /** Start time in milliseconds */
  tStartMs?: number;
  /** Duration in milliseconds */
  dDurationMs?: number;
  /** Segment array containing text parts */
  segs?: Array<{
    /** UTF-8 encoded text */
    utf8?: string;
    /** Text offset (for karaoke timing) */
    tOffsetMs?: number;
    /** Text accent (for styling) */
    acAsrConf?: number;
  }>;
  /** Window position */
  wWinId?: number;
  /** Alignment */
  aAppend?: number;
  /** Window style ID */
  wsWinStyleId?: number;
  /** Pen style ID */
  wpWinPosId?: number;
}

/**
 * YouTube JSON3 response structure
 */
interface JSON3Response {
  /** Wire format version */
  wireMagic?: string;
  /** Array of timed events */
  events?: JSON3Event[];
  /** WebSocket ID */
  wsWinStyles?: unknown[];
  /** Pen styles */
  wpWinPos?: unknown[];
  /** Whether auto-generated */
  pens?: unknown[];
}

/**
 * Parse JSON3 content into cues
 * @param content - JSON3 content string
 * @param options - Parsing options including ASR mode
 */
export function parseJSON3(content: string, options?: JSON3ParseOptions): JSON3ParseResult {
  let data: JSON3Response;
  
  try {
    data = JSON.parse(content) as JSON3Response;
  } catch (error) {
    throw new JSON3ParseError(`Invalid JSON: ${(error as Error).message}`);
  }
  
  if (!data.events || !Array.isArray(data.events)) {
    throw new JSON3ParseError('Missing or invalid events array');
  }
  
  // Detect ASR from options or from data structure
  // ASR subtitles often have acAsrConf (ASR confidence) values in segments
  const isASR = options?.isAutoGenerated ?? detectASRFromData(data);
  
  const cues: Cue[] = [];
  let cueIndex = 0;
  
  // For ASR: don't track lastEndTime to avoid time compression
  // For manual: track to handle overlapping cues
  let lastEndTime = 0;
  
  for (const event of data.events) {
    // Skip events without text segments
    if (!event.segs || event.segs.length === 0) {
      continue;
    }
    
    // Skip events without timing
    if (event.tStartMs === undefined) {
      continue;
    }
    
    const startTime = event.tStartMs;
    
    // Calculate end time from duration, or use next event's start
    let endTime: number;
    if (event.dDurationMs !== undefined && event.dDurationMs > 0) {
      endTime = startTime + event.dDurationMs;
    } else {
      // For ASR: use shorter default duration (2 seconds) to preserve natural flow
      // For manual: use 5 seconds as before
      endTime = startTime + (isASR ? 2000 : 5000);
    }
    
    // Combine all text segments
    const textParts: string[] = [];
    for (const seg of event.segs) {
      if (seg.utf8) {
        // Handle newline character
        if (seg.utf8 === '\n') {
          textParts.push('\n');
        } else {
          textParts.push(seg.utf8);
        }
      }
    }
    
    const text = textParts.join('').trim();
    
    // Skip empty or whitespace-only cues
    if (!text) {
      continue;
    }
    
    // For ASR: preserve original timing to maintain sync with audio
    // For manual: adjust if cue starts before the last one ended (handles overlaps)
    let adjustedStartTime: number;
    if (isASR) {
      // ASR: use original timing - this is critical for sync
      adjustedStartTime = startTime;
    } else {
      // Manual: adjust overlapping cues
      adjustedStartTime = Math.max(startTime, lastEndTime);
    }
    
    cues.push({
      index: cueIndex++,
      startTime: adjustedStartTime,
      endTime,
      text
    });
    
    lastEndTime = endTime;
  }
  
  // Post-process: merge consecutive cues
  // For ASR: skip merging to preserve timing granularity
  // For manual: merge duplicate cues (for karaoke-style subs)
  const processedCues = isASR ? cues : mergeDuplicateCues(cues);
  
  // Re-index after processing
  const reindexedCues = processedCues.map((cue, idx) => ({
    ...cue,
    index: idx
  }));
  
  return {
    cues: reindexedCues,
    metadata: {
      eventCount: data.events.length,
      isAutoGenerated: isASR
    }
  };
}

/**
 * Detect if subtitle data is auto-generated (ASR) based on content structure.
 * ASR subtitles typically have:
 * - acAsrConf (ASR confidence) values in segments
 * - Very short, frequent events
 * - pens array for styling
 */
function detectASRFromData(data: JSON3Response): boolean {
  // Check for pens array (often present in ASR)
  if (data.pens && Array.isArray(data.pens) && data.pens.length > 0) {
    return true;
  }
  
  // Check for acAsrConf in segments (ASR confidence scores)
  if (data.events) {
    for (const event of data.events) {
      if (event.segs) {
        for (const seg of event.segs) {
          if (seg.acAsrConf !== undefined) {
            return true;
          }
        }
      }
    }
  }
  
  // Check for characteristic short event durations (< 1 second average)
  if (data.events && data.events.length > 10) {
    let totalDuration = 0;
    let eventCount = 0;
    for (const event of data.events) {
      if (event.dDurationMs !== undefined && event.dDurationMs > 0) {
        totalDuration += event.dDurationMs;
        eventCount++;
      }
    }
    if (eventCount > 0) {
      const avgDuration = totalDuration / eventCount;
      // ASR typically has very short segments (< 1500ms average)
      if (avgDuration < 1500) {
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Merge consecutive cues with identical or very similar text
 * YouTube sometimes splits text across multiple events for karaoke effect
 */
function mergeDuplicateCues(cues: Cue[]): Cue[] {
  if (cues.length === 0) return cues;
  
  const merged: Cue[] = [];
  let current = cues[0];
  
  for (let i = 1; i < cues.length; i++) {
    const next = cues[i];
    
    // Merge if:
    // 1. Text is identical or current is prefix of next
    // 2. Time gap is small (< 100ms)
    const isSameText = current.text === next.text;
    const isPrefix = next.text.startsWith(current.text) && next.text.length <= current.text.length * 1.5;
    const isClose = next.startTime - current.endTime < 100;
    
    if ((isSameText || isPrefix) && isClose) {
      // Extend current cue
      current = {
        ...current,
        endTime: next.endTime,
        text: next.text.length > current.text.length ? next.text : current.text
      };
    } else {
      merged.push(current);
      current = next;
    }
  }
  
  merged.push(current);
  return merged;
}

/**
 * Validate JSON3 content
 */
export function isValidJSON3(content: string): boolean {
  try {
    const result = parseJSON3(content);
    return result.cues.length > 0;
  } catch {
    return false;
  }
}

/**
 * Check if content appears to be JSON3 format
 */
export function isJSON3Format(content: string): boolean {
  try {
    const data = JSON.parse(content) as JSON3Response;
    return Boolean(data.events && Array.isArray(data.events));
  } catch {
    return false;
  }
}
