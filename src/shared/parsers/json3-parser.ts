/**
 * JSON3 Parser
 * 
 * Parses YouTube's JSON3 subtitle format (timedtext API response).
 * This is a proprietary format used by YouTube for captions.
 */

import type { Cue } from '../types/subtitle';

/**
 * JSON3 parsing result
 */
export interface JSON3ParseResult {
  cues: Cue[];
  metadata: {
    /** Original events array length */
    eventCount: number;
    /** Whether the captions are auto-generated (ASR) */
    isAutoGenerated?: boolean;
    /** Language code from the response */
    languageCode?: string;
  };
}

/**
 * JSON3 parsing error
 */
export class JSON3ParseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'JSON3ParseError';
  }
}

/**
 * YouTube JSON3 event structure
 */
interface JSON3Event {
  /** Start time in milliseconds */
  tStartMs?: number;
  /** Duration in milliseconds */
  dDurationMs?: number;
  /** Segment array containing text parts */
  segs?: Array<{
    /** UTF-8 encoded text */
    utf8?: string;
    /** Text offset (for karaoke timing) */
    tOffsetMs?: number;
    /** Text accent (for styling) */
    acAsrConf?: number;
  }>;
  /** Window position */
  wWinId?: number;
  /** Alignment */
  aAppend?: number;
  /** Window style ID */
  wsWinStyleId?: number;
  /** Pen style ID */
  wpWinPosId?: number;
}

/**
 * YouTube JSON3 response structure
 */
interface JSON3Response {
  /** Wire format version */
  wireMagic?: string;
  /** Array of timed events */
  events?: JSON3Event[];
  /** WebSocket ID */
  wsWinStyles?: unknown[];
  /** Pen styles */
  wpWinPos?: unknown[];
  /** Whether auto-generated */
  pens?: unknown[];
}

/**
 * Parse JSON3 content into cues
 */
export function parseJSON3(content: string): JSON3ParseResult {
  let data: JSON3Response;
  
  try {
    data = JSON.parse(content) as JSON3Response;
  } catch (error) {
    throw new JSON3ParseError(`Invalid JSON: ${(error as Error).message}`);
  }
  
  if (!data.events || !Array.isArray(data.events)) {
    throw new JSON3ParseError('Missing or invalid events array');
  }
  
  const cues: Cue[] = [];
  let cueIndex = 0;
  
  // Track previous event end time for handling implicit durations
  let lastEndTime = 0;
  
  for (const event of data.events) {
    // Skip events without text segments
    if (!event.segs || event.segs.length === 0) {
      continue;
    }
    
    // Skip events without timing
    if (event.tStartMs === undefined) {
      continue;
    }
    
    const startTime = event.tStartMs;
    
    // Calculate end time from duration, or use next event's start
    let endTime: number;
    if (event.dDurationMs !== undefined && event.dDurationMs > 0) {
      endTime = startTime + event.dDurationMs;
    } else {
      // Default duration of 5 seconds if not specified
      endTime = startTime + 5000;
    }
    
    // Combine all text segments
    const textParts: string[] = [];
    for (const seg of event.segs) {
      if (seg.utf8) {
        // Handle newline character
        if (seg.utf8 === '\n') {
          textParts.push('\n');
        } else {
          textParts.push(seg.utf8);
        }
      }
    }
    
    const text = textParts.join('').trim();
    
    // Skip empty or whitespace-only cues
    if (!text) {
      continue;
    }
    
    // YouTube sometimes has overlapping or very short cues
    // Adjust if this cue starts before the last one ended
    const adjustedStartTime = Math.max(startTime, lastEndTime);
    
    cues.push({
      index: cueIndex++,
      startTime: adjustedStartTime,
      endTime,
      text
    });
    
    lastEndTime = endTime;
  }
  
  // Post-process: merge consecutive cues with same text (for karaoke-style subs)
  const mergedCues = mergeDuplicateCues(cues);
  
  // Re-index after merge
  const reindexedCues = mergedCues.map((cue, idx) => ({
    ...cue,
    index: idx
  }));
  
  return {
    cues: reindexedCues,
    metadata: {
      eventCount: data.events.length,
      isAutoGenerated: Boolean(data.pens && Array.isArray(data.pens) && data.pens.length > 0)
    }
  };
}

/**
 * Merge consecutive cues with identical or very similar text
 * YouTube sometimes splits text across multiple events for karaoke effect
 */
function mergeDuplicateCues(cues: Cue[]): Cue[] {
  if (cues.length === 0) return cues;
  
  const merged: Cue[] = [];
  let current = cues[0];
  
  for (let i = 1; i < cues.length; i++) {
    const next = cues[i];
    
    // Merge if:
    // 1. Text is identical or current is prefix of next
    // 2. Time gap is small (< 100ms)
    const isSameText = current.text === next.text;
    const isPrefix = next.text.startsWith(current.text) && next.text.length <= current.text.length * 1.5;
    const isClose = next.startTime - current.endTime < 100;
    
    if ((isSameText || isPrefix) && isClose) {
      // Extend current cue
      current = {
        ...current,
        endTime: next.endTime,
        text: next.text.length > current.text.length ? next.text : current.text
      };
    } else {
      merged.push(current);
      current = next;
    }
  }
  
  merged.push(current);
  return merged;
}

/**
 * Validate JSON3 content
 */
export function isValidJSON3(content: string): boolean {
  try {
    const result = parseJSON3(content);
    return result.cues.length > 0;
  } catch {
    return false;
  }
}

/**
 * Check if content appears to be JSON3 format
 */
export function isJSON3Format(content: string): boolean {
  try {
    const data = JSON.parse(content) as JSON3Response;
    return Boolean(data.events && Array.isArray(data.events));
  } catch {
    return false;
  }
}
