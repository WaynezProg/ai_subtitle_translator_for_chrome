/**
 * Real-time Subtitle Translator
 * 
 * Two modes:
 * 1. Time-sync mode: Uses pre-translated cues synced to video time
 * 2. DOM observer mode: Monitors YouTube's subtitle DOM for changes
 */

import type { Platform } from '../shared/types/subtitle';
import type { RenderOptions } from './adapters/types';
import { createLogger } from '../shared/utils/logger';

const log = createLogger('RealtimeTranslator');

// ============================================================================
// Types
// ============================================================================

interface TranslationCache {
  [sourceText: string]: string;
}

/** Pre-translated cue with timing info */
interface TranslatedCue {
  startTime: number;
  endTime: number;
  originalText: string;
  translatedText: string;
}

interface RealtimeTranslatorOptions {
  platform: Platform;
  targetLanguage: string;
  onTranslationRequest: (text: string) => Promise<string>;
  showOriginal?: boolean;
  hideNativeSubtitles?: boolean;
  /** Pre-translated cues for time-sync mode */
  translatedCues?: TranslatedCue[];
  /** Whether subtitles are auto-generated (ASR) - affects update frequency and progressive display */
  isAutoGenerated?: boolean;
  /** Render options for styling */
  renderOptions?: Partial<RenderOptions>;
  /**
   * Enable progressive text reveal for ASR subtitles.
   * When enabled, translated text is revealed character by character based on timing,
   * reducing the "time shift" perception when compared to YouTube's progressive ASR display.
   * Default: true for ASR subtitles, false for manual subtitles
   */
  progressiveReveal?: boolean;
}

type TranslatorState = 'idle' | 'active' | 'paused';

// ============================================================================
// Styles
// ============================================================================

const SUBTITLE_STYLES = `
  .ai-subtitle-overlay {
    position: absolute;
    bottom: 4%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2147483647;
    pointer-events: none;
    width: 90%;
    max-width: 1200px;
    text-align: center;
  }

  /* When native subtitles are visible, position our overlay higher to avoid overlap */
  .ai-subtitle-overlay.ai-subtitle-overlay-above-native {
    bottom: 15%;
  }

  .ai-subtitle-text {
    display: inline-block;
    padding: 16px 32px;
    border-radius: 8px;
    font-weight: 500;
    line-height: 1.5;
    max-width: 100%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    /* Default values - will be overridden by inline styles */
    background: rgba(0, 0, 0, 0.85);
    color: #fff;
    font-size: 28px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
    /* Smooth opacity transition for appearing/disappearing */
    transition: opacity 0.15s ease-out;
  }

  .ai-subtitle-original {
    display: block;
    opacity: 0.75;
    margin-bottom: 8px;
    font-weight: 400;
  }

  .ai-subtitle-translated {
    display: block;
    font-weight: 600;
  }

  /* Smooth text reveal using clip-path animation */
  .ai-subtitle-translated {
    display: inline;
  }

  .ai-subtitle-reveal-mask {
    display: inline;
    /* clip-path will be animated via JavaScript for smooth reveal */
  }

  /* Hide YouTube native subtitles when our translator is active */
  .ai-subtitle-hide-native .ytp-caption-window-container,
  .ai-subtitle-hide-native .caption-window {
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* Hide Netflix native subtitles */
  .ai-subtitle-hide-netflix .player-timedtext,
  .ai-subtitle-hide-netflix .player-timedtext-text-container {
    display: none !important;
    visibility: hidden !important;
  }
`;

// ============================================================================
// Realtime Translator Class
// ============================================================================

export class RealtimeTranslator {
  private options: RealtimeTranslatorOptions;
  private cache: TranslationCache = {};
  private observer: MutationObserver | null = null;
  private state: TranslatorState = 'idle';
  private styleElement: HTMLStyleElement | null = null;
  private overlayElement: HTMLElement | null = null;
  private videoElement: HTMLVideoElement | null = null;
  private timeUpdateHandler: (() => void) | null = null;
  private seekHandler: (() => void) | null = null;
  private currentCueIndex: number = -1;
  private lastDisplayedText: string = '';
  private lastDisplayedCueStart: number = -1;  // Track which cue is displayed by its start time
  private lastUpdateTime: number = 0;
  private pendingTranslations: Map<string, Promise<string>> = new Map();
  private translateDebounceTimer: ReturnType<typeof setTimeout> | null = null;
  
  // Time offset in milliseconds (positive = subtitles are ahead, negative = subtitles are behind)
  private timeOffset: number = 0;
  private timeOffsetCalibrated: boolean = false;
  
  // Render options for styling
  private renderOptions: Partial<RenderOptions> = {};

  // Progressive reveal state for ASR subtitles
  private progressiveRevealEnabled: boolean = false;
  private lastProgressiveText: string = '';
  private lastProgressiveLength: number = 0;
  private lastRevealRatio: number = 0;

  // Throttle interval for timeupdate (ms)
  // For ASR subtitles: use faster updates (100ms) for better sync with short segments
  // For manual subtitles: use slower updates (250ms) for performance
  // Reduced throttle intervals for faster subtitle updates with minimal delay
  private static readonly TIME_UPDATE_THROTTLE_NORMAL = 100;  // Was 250ms, now 100ms for faster response
  private static readonly TIME_UPDATE_THROTTLE_ASR = 50;       // Was 100ms, now 50ms for even faster ASR sync
  
  constructor(options: RealtimeTranslatorOptions) {
    // Determine hideNativeSubtitles from renderOptions if provided, otherwise use the direct option
    const hideNative = options.renderOptions?.hideNativeSubtitles ?? options.hideNativeSubtitles ?? true;

    // Build options with defaults first, then override with provided options
    const baseOptions = {
      showOriginal: true,
      hideNativeSubtitles: true,
      isAutoGenerated: false,
    };

    this.options = {
      ...baseOptions,
      ...options,
    };

    // Ensure hideNativeSubtitles respects the computed value (renderOptions takes precedence)
    this.options.hideNativeSubtitles = hideNative;

    // Enable progressive reveal by default for ASR subtitles
    // This reduces the perceived "time shift" between progressive ASR display and instant translation
    this.progressiveRevealEnabled = options.progressiveReveal ?? (options.isAutoGenerated ?? false);

    // NOTE: We keep the reference to the original translatedCues array
    // This allows the content script to update translations in-place
    // The caller is responsible for ensuring cues are sorted by startTime
    this.renderOptions = options.renderOptions || {};
  }
  
  /**
   * Get the appropriate throttle interval based on subtitle type
   */
  private getThrottleInterval(): number {
    return this.options.isAutoGenerated 
      ? RealtimeTranslator.TIME_UPDATE_THROTTLE_ASR 
      : RealtimeTranslator.TIME_UPDATE_THROTTLE_NORMAL;
  }
  
  /**
   * Set time offset for subtitle synchronization
   * @param offsetMs Offset in milliseconds (positive = delay subtitles, negative = advance subtitles)
   */
  setTimeOffset(offsetMs: number): void {
    this.timeOffset = offsetMs;
    this.timeOffsetCalibrated = true;
    log.debug(` Time offset set to ${offsetMs}ms`);
    // Force update with new offset
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Get current time offset
   */
  getTimeOffset(): number {
    return this.timeOffset;
  }
  
  /**
   * Force refresh the current cue display.
   * Call this after translations have been updated to show new translations immediately.
   */
  refreshCurrentCue(): void {
    if (this.state !== 'active' || !this.videoElement) {
      return;
    }
    // Reset display tracking to force re-render
    this.lastDisplayedText = '';
    this.lastDisplayedCueStart = -1;
    this.lastProgressiveLength = 0;
    // Trigger immediate update
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Update render options and re-apply styles
   */
  updateRenderOptions(options: Partial<RenderOptions>): void {
    this.renderOptions = { ...this.renderOptions, ...options };

    // Update showOriginal from bilingual setting
    if (options.bilingual !== undefined) {
      this.options.showOriginal = options.bilingual;
    }

    // Handle hideNativeSubtitles changes
    if (options.hideNativeSubtitles !== undefined) {
      this.options.hideNativeSubtitles = options.hideNativeSubtitles;
      if (options.hideNativeSubtitles) {
        this.hideNativeSubtitles();
        this.overlayElement?.classList.remove('ai-subtitle-overlay-above-native');
      } else {
        this.showNativeSubtitles();
        this.overlayElement?.classList.add('ai-subtitle-overlay-above-native');
      }
    }

    // Re-apply styles to overlay if it exists
    if (this.overlayElement) {
      this.applyRenderOptionsToOverlay();
    }

    // Force refresh to show changes
    this.refreshCurrentCue();

    log.debug('Render options updated:', options);
  }
  
  /**
   * Update the translated cues (used when uploading external translations)
   * NOTE: This replaces the cues array reference. For in-place updates during
   * background translation, modify the existing array elements directly.
   */
  updateTranslatedCues(cues: TranslatedCue[]): void {
    this.options.translatedCues = cues;
    log.debug(` Updated translated cues: ${cues.length} cues`);
  }
  
  /**
   * Apply render options to the overlay element
   */
  private applyRenderOptionsToOverlay(): void {
    if (!this.overlayElement) return;
    
    const opts = this.renderOptions;
    
    // Apply position to overlay container
    if (opts.position === 'top') {
      this.overlayElement.style.bottom = 'auto';
      this.overlayElement.style.top = '10%';
    } else {
      this.overlayElement.style.top = 'auto';
      this.overlayElement.style.bottom = '10%';
    }
    
    // Apply font settings to existing subtitle text elements
    const textElements = this.overlayElement.querySelectorAll('.ai-subtitle-text');
    textElements.forEach((el) => {
      this.applyStylesToElement(el as HTMLElement);
    });
  }
  
  /**
   * Auto-calibrate time offset by finding the first cue
   */
  private autoCalibrate(): void {
    if (this.timeOffsetCalibrated || !this.videoElement || !this.options.translatedCues) {
      return;
    }
    
    const cues = this.options.translatedCues;
    if (cues.length === 0) return;
    
    // Find the first cue's start time
    const firstCueStart = cues[0].startTime;
    
    // If first cue starts very late (> 30 seconds), it might indicate an offset issue
    // Netflix sometimes has credits/intro that aren't in subtitles
    if (firstCueStart > 30000) {
      log.debug(` First cue starts at ${firstCueStart}ms - may need offset adjustment`);
    }
    
    this.timeOffsetCalibrated = true;
  }
  
  /**
   * Start the translator
   */
  start(): void {
    if (this.state === 'active') {
      log.debug('Already active');
      return;
    }
    
    log.debug('Starting...');
    this.state = 'active';
    
    // Inject styles
    this.injectStyles();
    
    // Create overlay
    this.createOverlay();
    
    // Hide native subtitles
    if (this.options.hideNativeSubtitles) {
      this.hideNativeSubtitles();
    }
    
    // Choose mode based on whether we have pre-translated cues
    if (this.options.translatedCues && this.options.translatedCues.length > 0) {
      log.debug(`Using time-sync mode with ${this.options.translatedCues.length} cues`);
      this.startTimeSyncMode();
    } else {
      log.debug('Using DOM observer mode');
      this.startObserverMode();
    }
  }
  
  /**
   * Stop the translator
   */
  stop(): void {
    log.debug('Stopping...');
    this.state = 'idle';
    
    // Stop time sync
    this.stopTimeSyncMode();
    
    // Stop observer
    this.stopObserverMode();
    
    // Clear debounce timer
    if (this.translateDebounceTimer) {
      clearTimeout(this.translateDebounceTimer);
      this.translateDebounceTimer = null;
    }
    
    // Show native subtitles again
    this.showNativeSubtitles();
    
    // Remove overlay
    this.removeOverlay();
    
    // Remove styles
    this.removeStyles();
    
    // Clear state
    this.pendingTranslations.clear();
    this.currentCueIndex = -1;
    this.lastDisplayedText = '';
    this.lastDisplayedCueStart = -1;
    this.lastProgressiveLength = 0;
    this.lastRevealRatio = 0;
    this.cache = {};

    // Reset cached DOM elements
    this.resetCachedElements();

    // Clear translated cues reference to allow garbage collection
    this.options.translatedCues = undefined;
  }
  
  /**
   * Get current state
   */
  getState(): TranslatorState {
    return this.state;
  }
  
  // ============================================================================
  // Time-Sync Mode (for pre-translated subtitles)
  // ============================================================================
  
  private startTimeSyncMode(): void {
    // Find video element
    this.videoElement = document.querySelector('video');
    if (!this.videoElement) {
      console.warn('[RealtimeTranslator] Video element not found');
      return;
    }
    
    // Throttled handler for regular time updates (performance optimization)
    this.timeUpdateHandler = (): void => this.onTimeUpdateThrottled();

    // Immediate handler for seek events (responsive UX)
    this.seekHandler = (): void => this.onTimeUpdateImmediate();
    
    // Regular time updates - throttled for performance
    this.videoElement.addEventListener('timeupdate', this.timeUpdateHandler);
    
    // Seek events - immediate response for good UX
    this.videoElement.addEventListener('seeking', this.seekHandler);
    this.videoElement.addEventListener('seeked', this.seekHandler);
    this.videoElement.addEventListener('playing', this.seekHandler);
    this.videoElement.addEventListener('play', this.seekHandler);
    
    // Immediately update to current position
    this.onTimeUpdateImmediate();
    
    log.debug('Time-sync mode started');
  }
  
  private stopTimeSyncMode(): void {
    if (this.videoElement) {
      if (this.timeUpdateHandler) {
        this.videoElement.removeEventListener('timeupdate', this.timeUpdateHandler);
      }
      if (this.seekHandler) {
        this.videoElement.removeEventListener('seeking', this.seekHandler);
        this.videoElement.removeEventListener('seeked', this.seekHandler);
        this.videoElement.removeEventListener('playing', this.seekHandler);
        this.videoElement.removeEventListener('play', this.seekHandler);
      }
    }
    this.videoElement = null;
    this.timeUpdateHandler = null;
    this.seekHandler = null;
  }
  
  /**
   * Throttled time update - called frequently but only processes every N ms
   * Uses faster throttle for ASR subtitles to maintain sync with short segments
   */
  private onTimeUpdateThrottled(): void {
    const now = Date.now();
    const throttleInterval = this.getThrottleInterval();
    if (now - this.lastUpdateTime < throttleInterval) {
      return; // Skip this update
    }
    this.lastUpdateTime = now;
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Immediate time update - for seek events and initial load
   */
  private onTimeUpdateImmediate(): void {
    if (this.state !== 'active' || !this.videoElement || !this.options.translatedCues) {
      return;
    }

    // Auto-calibrate on first update
    this.autoCalibrate();

    // Apply time offset: subtract offset from video time to match subtitle time
    // If subtitles are ahead (showing too early), use positive offset
    // If subtitles are behind (showing too late), use negative offset
    const currentTime = (this.videoElement.currentTime * 1000) - this.timeOffset;
    const cues = this.options.translatedCues;

    // Use binary search for better performance with large cue lists
    const activeCue = this.findActiveCue(cues, currentTime);

    // Update display if cue changed
    if (activeCue) {
      // Check if this cue hasn't been translated yet (translation equals original)
      const needsTranslation = activeCue.translatedText === activeCue.originalText &&
                               activeCue.originalText.trim().length > 0;

      if (needsTranslation) {
        // Trigger on-demand translation for the current cue
        this.translateCurrentCueOnDemand(activeCue);
      }

      // Use CSS typewriter animation for gradual text reveal
      const cueChanged = activeCue.startTime !== this.lastDisplayedCueStart;
      const textChanged = activeCue.translatedText !== this.lastDisplayedText;

      if (cueChanged || textChanged) {
        this.lastDisplayedText = activeCue.translatedText;
        this.lastDisplayedCueStart = activeCue.startTime;
        const cueDuration = activeCue.endTime - activeCue.startTime;
        this.updateOverlaySimple(
          activeCue.originalText,
          activeCue.translatedText,
          cueChanged,  // trigger typewriter animation on cue change
          cueDuration
        );
      }
    } else {
      // No active cue, clear display
      if (this.lastDisplayedText !== '' || this.lastDisplayedCueStart !== -1) {
        this.lastDisplayedText = '';
        this.lastDisplayedCueStart = -1;
        this.lastProgressiveLength = 0;
        this.clearOverlay();
      }
    }
  }

  /**
   * Translate the current cue on-demand if it hasn't been translated yet.
   * This ensures the user always sees a translation for what they're currently watching,
   * even if the batch translation hasn't reached this cue yet.
   */
  private translateCurrentCueOnDemand(cue: TranslatedCue): void {
    const text = cue.originalText.trim();

    // Skip if already pending or recently attempted
    if (this.pendingTranslations.has(text)) {
      return;
    }

    // Request translation via the callback
    const promise = this.options.onTranslationRequest(text)
      .then(result => {
        // Update the cue with the translation
        if (result && result !== text) {
          cue.translatedText = result;
          this.cache[text] = result;

          // Immediately refresh display to show the new translation
          if (this.state === 'active') {
            this.lastDisplayedText = ''; // Force refresh
            this.lastDisplayedCueStart = -1; // Also reset cue tracking
            this.lastProgressiveLength = 0; // Reset progressive reveal
            this.onTimeUpdateImmediate();
          }
        }
        this.pendingTranslations.delete(text);
        return result;
      })
      .catch(error => {
        console.error('[RealtimeTranslator] On-demand translation error:', error);
        this.pendingTranslations.delete(text);
        throw error;
      });

    this.pendingTranslations.set(text, promise);
  }
  
  /**
   * Calculate progressive text reveal for ASR subtitles.
   * This reveals the translation character by character based on progress through the cue,
   * reducing the perception of "time shift" compared to YouTube's progressive ASR display.
   *
   * The reveal strategy uses a smooth ease-in-out curve to avoid abrupt jumps:
   * - Start: Small initial reveal (15%) to give context without jarring appearance
   * - Middle: Smooth ease-in-out curve that accelerates then decelerates
   * - End: Full text shown by 85% of duration for comfortable reading
   *
   * This creates a natural, smooth reveal that matches the cadence of speech
   * without sudden "jumps" of text appearing.
   */
  private calculateProgressiveReveal(
    cue: TranslatedCue,
    currentTime: number
  ): { revealedTranslation: string; revealedOriginal: string } {
    const fullTranslation = cue.translatedText;
    const fullOriginal = cue.originalText;
    const duration = cue.endTime - cue.startTime;

    // Edge case: very short or zero duration - show full text immediately
    if (duration <= 0) {
      return { revealedTranslation: fullTranslation, revealedOriginal: fullOriginal };
    }

    // For very short cues (< 800ms), show full text immediately
    // These are typically single words or brief phrases
    if (duration < 800) {
      return { revealedTranslation: fullTranslation, revealedOriginal: fullOriginal };
    }

    // For short cues (800ms - 2s), show full text immediately
    // No progressive reveal - CSS handles smooth appearance
    if (duration < 2000) {
      return { revealedTranslation: fullTranslation, revealedOriginal: fullOriginal };
    }

    // Calculate progress through the cue (0.0 to 1.0)
    const elapsed = currentTime - cue.startTime;
    const progress = Math.max(0, Math.min(1, elapsed / duration));

    // Linear reveal strategy for consistent character-by-character appearance
    // Using linear ensures the same number of characters per time unit,
    // preventing "chunky" reveals that happen with easing curves
    const revealRatio = this.calculateSmoothRevealRatio(progress);

    // Calculate characters to show
    // Use Math.round for smoother single-character progression
    // (Math.ceil caused multiple characters to appear at once)
    const translationLength = Math.max(1, Math.round(fullTranslation.length * revealRatio));
    const originalLength = Math.max(1, Math.round(fullOriginal.length * revealRatio));

    // Reveal text, preferring word boundaries when possible for non-CJK text
    const revealedTranslation = this.revealTextProgressively(fullTranslation, translationLength);
    const revealedOriginal = this.revealTextProgressively(fullOriginal, originalLength);

    return { revealedTranslation, revealedOriginal };
  }

  /**
   * Calculate reveal ratio for word-by-word reveal.
   *
   * The key insight: we want a very small initial reveal (just enough
   * to show something), then smooth linear progression.
   *
   * @param progress - Progress through the cue (0.0 to 1.0)
   * @returns Reveal ratio (0.05 to 1.0) for word count calculation
   */
  private calculateSmoothRevealRatio(progress: number): number {
    // Very small minimum - just 5% to show 1-4 characters initially
    // This avoids both "empty" state AND "too much at once"
    const MIN_REVEAL = 0.05;
    // Complete reveal by 80% of duration for comfortable reading
    const FULL_REVEAL_PROGRESS = 0.80;

    if (progress >= FULL_REVEAL_PROGRESS) {
      return 1.0;
    }

    // Linear progression from MIN_REVEAL to 1.0
    const progressRatio = progress / FULL_REVEAL_PROGRESS;
    return MIN_REVEAL + ((1.0 - MIN_REVEAL) * progressRatio);
  }

  /**
   * Split text into segments for word-by-word reveal.
   * For CJK: splits into 2-character pairs for smoother visual flow
   * For Latin: splits by words
   *
   * Using 2-char segments balances smoothness vs too many updates
   */
  private splitTextIntoSegments(text: string): string[] {
    if (!text) return [];

    // Check if text contains CJK characters
    const hasCJK = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(text);

    if (hasCJK) {
      // For CJK text, split into pairs of characters
      // This creates smoother visual flow than single chars
      const segments: string[] = [];
      const punctuation = /[，。！？、；：「」『』【】（）《》…—～·\s]/;
      let current = '';

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        current += char;

        // Split at punctuation OR every 2 characters
        const isPunctuation = punctuation.test(char);
        const isAtPairBoundary = current.length >= 2;

        if (isPunctuation || isAtPairBoundary) {
          // Include any following punctuation
          while (i + 1 < text.length && punctuation.test(text[i + 1])) {
            i++;
            current += text[i];
          }

          if (current.trim()) {
            segments.push(current);
          }
          current = '';
        }
      }

      // Don't forget remaining text
      if (current.trim()) {
        segments.push(current);
      }

      return segments;
    }

    // For Latin text, split by whitespace but keep words together
    return text.split(/(\s+)/).filter(s => s.length > 0);
  }

  /**
   * Calculate how many segments to reveal based on progress.
   * Always shows at least 1 segment to avoid empty display.
   */
  private getVisibleSegmentCount(segments: string[], revealRatio: number): number {
    if (segments.length === 0) return 0;
    if (revealRatio >= 1) return segments.length;

    // Always show at least 1 segment to avoid "empty" state
    // This prevents the jarring "nothing to something" transition
    const count = Math.round(segments.length * revealRatio);
    return Math.max(1, count);
  }

  /**
   * Reveal text progressively - now returns segment info for word-by-word rendering.
   * This is kept for backward compatibility but the actual rendering uses segments.
   */
  private revealTextProgressively(text: string, targetLength: number): string {
    // For backward compatibility, just return the text up to target length
    if (targetLength >= text.length) {
      return text;
    }
    if (targetLength <= 0) {
      return '';
    }
    return text.substring(0, targetLength);
  }

  /**
   * Find active cue using linear search for reliability
   * Linear search is more reliable when cues may have overlapping times or gaps
   * For typical subtitle files (~500 cues), performance is acceptable
   *
   * For ASR subtitles, we use an intelligent "grace period" approach:
   * - If currentTime is within a cue's time range, return that cue
   * - If currentTime is in a gap between cues:
   *   - For very short gaps (≤500ms): extend previous cue for up to 400ms (seamless)
   *   - For short gaps (500-1000ms): extend previous cue for up to 350ms
   *   - For medium gaps (1000-1500ms): extend previous cue for up to 250ms
   *   - For longer gaps: show nothing (natural pause in speech)
   *
   * These values are optimized for YouTube ASR subtitles to reduce flickering
   * while maintaining natural speech rhythm perception.
   */
  private findActiveCue(cues: TranslatedCue[], currentTime: number): TranslatedCue | null {
    if (cues.length === 0) return null;

    // First pass: find exact match
    for (const cue of cues) {
      if (currentTime >= cue.startTime && currentTime < cue.endTime) {
        return cue;
      }
    }

    // Second pass: handle gaps between cues for smoother display
    // This prevents subtitle "flicker" during small time gaps in ASR content
    for (let i = 0; i < cues.length - 1; i++) {
      const currentCue = cues[i];
      const nextCue = cues[i + 1];
      const gapStart = currentCue.endTime;
      const gapEnd = nextCue.startTime;

      // Check if currentTime is in the gap between two cues
      if (currentTime >= gapStart && currentTime < gapEnd) {
        const gapDuration = gapEnd - gapStart;
        const timeIntoGap = currentTime - gapStart;

        // Determine grace period based on gap duration
        // Optimized for YouTube ASR which has many small gaps between words
        let gracePeriod: number;
        if (gapDuration <= 500) {
          // Very short gap: nearly seamless transition
          gracePeriod = 400;
        } else if (gapDuration <= 1000) {
          // Short gap: likely brief pause, extend up to 350ms
          gracePeriod = 350;
        } else if (gapDuration <= 1500) {
          // Medium gap: likely sentence boundary, extend up to 250ms
          gracePeriod = 250;
        } else {
          // Long gap: intentional pause, don't extend (show nothing)
          gracePeriod = 0;
        }

        // If we're within the grace period, show the previous cue
        if (gracePeriod > 0 && timeIntoGap <= gracePeriod) {
          return currentCue;
        }
        // Otherwise, show nothing (let next cue appear naturally)
        break;
      }
    }

    return null;
  }
  
  // ============================================================================
  // DOM Observer Mode (fallback for real-time translation)
  // ============================================================================
  
  private startObserverMode(): void {
    const container = this.findCaptionContainer();
    
    if (!container) {
      log.debug('Caption container not found, will retry...');
      setTimeout(() => {
        if (this.state === 'active') {
          this.startObserverMode();
        }
      }, 1000);
      return;
    }
    
    log.debug('Caption container found');
    
    this.observer = new MutationObserver(() => {
      if (this.state === 'active') {
        this.onSubtitleChange();
      }
    });
    
    this.observer.observe(container, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }
  
  private stopObserverMode(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }
  
  private findCaptionContainer(): Element | null {
    const selectors = [
      '.ytp-caption-window-container',
      '.caption-window',
      '#movie_player .ytp-caption-window-container',
    ];
    
    for (const selector of selectors) {
      const container = document.querySelector(selector);
      if (container) return container;
    }
    
    return null;
  }
  
  private onSubtitleChange(): void {
    const container = this.findCaptionContainer();
    if (!container) return;
    
    // Get text from caption segments
    const segments = container.querySelectorAll('.ytp-caption-segment');
    let fullText = '';
    
    if (segments.length > 0) {
      fullText = Array.from(segments)
        .map(s => s.textContent?.trim())
        .filter(Boolean)
        .join(' ');
    }
    
    // Clean and validate text
    fullText = this.cleanSubtitleText(fullText);
    if (!fullText || fullText === this.lastDisplayedText || fullText.length < 2) {
      return;
    }
    
    this.lastDisplayedText = fullText;
    this.debounceTranslate(fullText);
  }
  
  private debounceTranslate(text: string): void {
    if (this.translateDebounceTimer) {
      clearTimeout(this.translateDebounceTimer);
    }
    
    // Show original immediately
    this.updateOverlay(text, '', true);
    
    this.translateDebounceTimer = setTimeout(() => {
      void this.doTranslate(text);
    }, 300);
  }
  
  private async doTranslate(text: string): Promise<void> {
    if (text !== this.lastDisplayedText) return;
    
    try {
      const translation = await this.translateText(text);
      if (text === this.lastDisplayedText && this.state === 'active') {
        this.updateOverlay(text, translation);
      }
    } catch (error) {
      console.error('[RealtimeTranslator] Translation error:', error);
    }
  }
  
  private async translateText(text: string): Promise<string> {
    // Check cache
    if (this.cache[text]) {
      return this.cache[text];
    }
    
    // Check pending
    if (this.pendingTranslations.has(text)) {
      return this.pendingTranslations.get(text)!;
    }
    
    const promise = this.options.onTranslationRequest(text)
      .then(result => {
        this.cache[text] = result;
        this.pendingTranslations.delete(text);
        return result;
      })
      .catch(error => {
        this.pendingTranslations.delete(text);
        throw error;
      });
    
    this.pendingTranslations.set(text, promise);
    return promise;
  }
  
  private cleanSubtitleText(text: string): string {
    const patterns = [
      /日文\s*\(自動產生\)/g,
      /英文\s*\(自動產生\)/g,
      /中文\s*\(自動產生\)/g,
      /\(自動產生\)/g,
      /按一下.*$/g,
      /點擊.*$/g,
      /Auto-generated/gi,
    ];
    
    let cleaned = text;
    for (const pattern of patterns) {
      cleaned = cleaned.replace(pattern, '');
    }
    
    return cleaned.trim();
  }
  
  // ============================================================================
  // UI Methods
  // ============================================================================
  
  private injectStyles(): void {
    if (this.styleElement) return;
    
    this.styleElement = document.createElement('style');
    this.styleElement.id = 'ai-subtitle-translator-styles';
    this.styleElement.textContent = SUBTITLE_STYLES;
    document.head.appendChild(this.styleElement);
  }
  
  private removeStyles(): void {
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  
  private createOverlay(): void {
    if (this.overlayElement) return;
    
    // Platform-specific player selectors
    const playerSelectors = [
      // YouTube
      '#movie_player',
      '.html5-video-player',
      // Netflix
      '.watch-video--player-view',
      '.VideoContainer',
      '[data-uia="video-canvas"]',
      // Disney+
      '.btm-media-client-element',
      // Prime Video
      '.webPlayerContainer',
      '.dv-player-fullscreen',
      // Generic fallback
      'video',
    ];
    
    let player: Element | null = null;
    for (const selector of playerSelectors) {
      player = document.querySelector(selector);
      if (player) {
        log.debug(`Found player container: ${selector}`);
        break;
      }
    }
    
    if (!player) {
      console.warn('[RealtimeTranslator] Video player not found, using body as fallback');
      player = document.body;
    }
    
    // For video element, use its parent
    if (player.tagName === 'VIDEO') {
      player = player.parentElement || document.body;
    }
    
    this.overlayElement = document.createElement('div');
    this.overlayElement.className = 'ai-subtitle-overlay';
    this.overlayElement.id = 'ai-subtitle-overlay';

    // If native subtitles are NOT hidden, position our overlay higher to avoid overlap
    // This allows users to see both native progressive subtitles and our translation
    if (!this.options.hideNativeSubtitles) {
      this.overlayElement.classList.add('ai-subtitle-overlay-above-native');
      log.debug('Native subtitles visible, positioning overlay above');
    }

    // Ensure parent has position for absolute positioning
    const computedStyle = window.getComputedStyle(player);
    if (computedStyle.position === 'static') {
      (player as HTMLElement).style.position = 'relative';
    }

    player.appendChild(this.overlayElement);
    log.debug('Overlay created and attached');
  }
  
  private removeOverlay(): void {
    if (this.overlayElement) {
      this.overlayElement.remove();
      this.overlayElement = null;
    }
  }
  
  private hideNativeSubtitles(): void {
    // YouTube
    const ytPlayer = document.querySelector('#movie_player, .html5-video-player');
    if (ytPlayer) {
      ytPlayer.classList.add('ai-subtitle-hide-native');
    }
    
    // Netflix - hide the native subtitle container with multiple methods for reliability
    const netflixSelectors = [
      '.player-timedtext',
      '.player-timedtext-text-container',
      '[data-uia="player"]  .player-timedtext',
    ];
    
    for (const selector of netflixSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        (el as HTMLElement).style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
      });
    }
    
    // Also add class to body for CSS-based hiding
    document.body.classList.add('ai-subtitle-hide-netflix');
  }
  
  private showNativeSubtitles(): void {
    // YouTube
    const ytPlayer = document.querySelector('#movie_player, .html5-video-player');
    if (ytPlayer) {
      ytPlayer.classList.remove('ai-subtitle-hide-native');
    }
    
    // Netflix - restore native subtitles
    const netflixSelectors = [
      '.player-timedtext',
      '.player-timedtext-text-container',
      '[data-uia="player"] .player-timedtext',
    ];
    
    for (const selector of netflixSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        (el as HTMLElement).style.cssText = '';
      });
    }
    
    document.body.classList.remove('ai-subtitle-hide-netflix');
  }
  
  // Cached DOM elements for smooth updates (avoid recreating elements)
  private subtitleContainer: HTMLDivElement | null = null;
  private originalSpan: HTMLSpanElement | null = null;
  private translatedSpan: HTMLSpanElement | null = null;

  private updateOverlay(originalText: string, translatedText: string, isLoading: boolean = false): void {
    if (!this.overlayElement) {
      console.warn('[RealtimeTranslator] updateOverlay called but overlay not created');
      this.createOverlay();
      if (!this.overlayElement) {
        console.error('[RealtimeTranslator] Failed to create overlay');
        return;
      }
    }

    // If no text, hide but don't destroy elements (for smooth transitions)
    if (!translatedText && !originalText) {
      if (this.subtitleContainer) {
        this.subtitleContainer.style.opacity = '0';
      }
      return;
    }

    // Create or reuse container - avoid DOM thrashing
    if (!this.subtitleContainer || !this.overlayElement.contains(this.subtitleContainer)) {
      // Clear any old content
      while (this.overlayElement.firstChild) {
        this.overlayElement.removeChild(this.overlayElement.firstChild);
      }

      this.subtitleContainer = document.createElement('div');
      this.subtitleContainer.className = 'ai-subtitle-text';
      this.applyStylesToElement(this.subtitleContainer);

      // Create original text span (may be hidden based on settings)
      this.originalSpan = document.createElement('span');
      this.originalSpan.className = 'ai-subtitle-original';
      this.subtitleContainer.appendChild(this.originalSpan);

      // Create translated text span
      this.translatedSpan = document.createElement('span');
      this.translatedSpan.className = 'ai-subtitle-translated';
      this.subtitleContainer.appendChild(this.translatedSpan);

      this.overlayElement.appendChild(this.subtitleContainer);
    }

    // Ensure container is visible
    this.subtitleContainer.style.opacity = '1';

    // Update original text span
    if (this.originalSpan) {
      if (this.options.showOriginal && originalText) {
        this.originalSpan.textContent = originalText;
        this.originalSpan.style.display = 'block';
      } else {
        this.originalSpan.style.display = 'none';
      }
    }

    // Update translated text span - just update textContent, no DOM recreation
    if (this.translatedSpan) {
      this.translatedSpan.textContent = isLoading ? '翻譯中...' : (translatedText || originalText);
    }
  }

  // Cache for current segments to avoid recreating DOM
  private currentSegments: string[] = [];
  private segmentSpans: HTMLSpanElement[] = [];

  /**
   * Update overlay with word-by-word segment reveal.
   * Each segment fades in smoothly using CSS transitions.
   * Key optimization: reuse existing spans, only update visibility.
   */
  private updateOverlayWithSegments(
    originalText: string,
    translatedText: string,
    revealRatio: number
  ): void {
    if (!this.overlayElement) {
      this.createOverlay();
      if (!this.overlayElement) return;
    }

    if (!translatedText && !originalText) {
      if (this.subtitleContainer) {
        this.subtitleContainer.style.opacity = '0';
      }
      return;
    }

    // Create or reuse container
    if (!this.subtitleContainer || !this.overlayElement.contains(this.subtitleContainer)) {
      while (this.overlayElement.firstChild) {
        this.overlayElement.removeChild(this.overlayElement.firstChild);
      }

      this.subtitleContainer = document.createElement('div');
      this.subtitleContainer.className = 'ai-subtitle-text';
      this.applyStylesToElement(this.subtitleContainer);

      this.originalSpan = document.createElement('span');
      this.originalSpan.className = 'ai-subtitle-original';
      this.subtitleContainer.appendChild(this.originalSpan);

      this.translatedSpan = document.createElement('span');
      this.translatedSpan.className = 'ai-subtitle-translated';
      this.subtitleContainer.appendChild(this.translatedSpan);

      this.overlayElement.appendChild(this.subtitleContainer);
    }

    this.subtitleContainer.style.opacity = '1';

    // Update original text (show fully, no progressive reveal)
    if (this.originalSpan) {
      if (this.options.showOriginal && originalText) {
        this.originalSpan.textContent = originalText;
        this.originalSpan.style.display = 'block';
      } else {
        this.originalSpan.style.display = 'none';
      }
    }

    // Update translated text with word-by-word reveal
    if (this.translatedSpan) {
      const segments = this.splitTextIntoSegments(translatedText);
      const visibleCount = this.getVisibleSegmentCount(segments, revealRatio);

      // Check if segments changed (new cue) - need to rebuild spans
      const segmentsChanged = segments.length !== this.currentSegments.length ||
        segments.some((s, i) => s !== this.currentSegments[i]);

      if (segmentsChanged) {
        // New text - rebuild all spans
        this.currentSegments = segments;
        this.segmentSpans = [];

        // Clear existing content
        while (this.translatedSpan.firstChild) {
          this.translatedSpan.removeChild(this.translatedSpan.firstChild);
        }

        // Create spans for each segment
        // Initially visible segments start with opacity:1 (no transition delay)
        // Hidden segments start with opacity:0 and will transition when revealed
        segments.forEach((segment, index) => {
          const span = document.createElement('span');
          span.className = 'ai-subtitle-word';
          span.textContent = segment;

          // Make initially visible segments visible immediately (no flash)
          if (index < visibleCount) {
            span.classList.add('ai-subtitle-word-visible');
          }

          this.segmentSpans.push(span);
          this.translatedSpan!.appendChild(span);
        });
      } else {
        // Same text - just update visibility of existing spans
        this.segmentSpans.forEach((span, index) => {
          if (index < visibleCount) {
            if (!span.classList.contains('ai-subtitle-word-visible')) {
              span.classList.add('ai-subtitle-word-visible');
            }
          }
          // Note: we don't remove visibility - once shown, stays shown
        });
      }
    }
  }

  /**
   * Apply current render options to a subtitle element
   */
  private applyStylesToElement(element: HTMLElement): void {
    const opts = this.renderOptions;
    
    // Font size - apply to container
    if (opts.fontSize !== undefined) {
      element.style.fontSize = `${opts.fontSize}px`;
    }
    
    // Font family
    if (opts.fontFamily !== undefined) {
      element.style.fontFamily = opts.fontFamily;
    }
    
    // Font color
    if (opts.fontColor !== undefined) {
      element.style.color = opts.fontColor;
    }
    
    // Apply background style
    if (opts.background === 'none') {
      element.style.background = 'transparent';
      element.style.boxShadow = 'none';
      element.style.padding = '8px 16px';
      // For "none" background, use outline text for readability
      element.style.textShadow = `-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 
                                   -2px 0 0 #000, 2px 0 0 #000, 0 -2px 0 #000, 0 2px 0 #000`;
    } else if (opts.background === 'shadow') {
      element.style.background = 'transparent';
      element.style.boxShadow = 'none';
      element.style.padding = '8px 16px';
      element.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.9), 0 0 8px rgba(0, 0, 0, 0.8)';
    } else if (opts.background === 'box') {
      element.style.background = 'rgba(0, 0, 0, 0.85)';
      element.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
      element.style.padding = '16px 32px';
      element.style.textShadow = 'none';
    }
  }
  
  private clearOverlay(): void {
    // Just hide the container instead of destroying DOM elements
    // This allows for smoother transitions when text reappears
    if (this.subtitleContainer) {
      this.subtitleContainer.style.opacity = '0';
    }
  }

  /**
   * Reset cached DOM elements (called during cleanup)
   */
  private resetCachedElements(): void {
    this.subtitleContainer = null;
    this.originalSpan = null;
    this.translatedSpan = null;
    this.currentSegments = [];
    this.segmentSpans = [];
    this.stopRevealAnimation();
  }

  // Animation state for smooth reveal
  private revealAnimationId: number | null = null;
  private revealStartTime: number = 0;
  private revealDuration: number = 0;
  private currentRevealProgress: number = 1; // 0 to 1

  /**
   * Simple overlay update with smooth progressive reveal.
   * Uses requestAnimationFrame for buttery-smooth character reveal.
   *
   * @param originalText - The original subtitle text
   * @param translatedText - The translated subtitle text
   * @param triggerAnimation - Whether to trigger the reveal animation (on cue change)
   * @param cueDuration - Duration of the cue in milliseconds (for animation timing)
   */
  private updateOverlaySimple(
    originalText: string,
    translatedText: string,
    triggerAnimation: boolean,
    cueDuration: number = 3000
  ): void {
    if (!this.overlayElement) {
      this.createOverlay();
      if (!this.overlayElement) return;
    }

    // If no text, hide container and stop animation
    if (!translatedText && !originalText) {
      if (this.subtitleContainer) {
        this.subtitleContainer.style.opacity = '0';
      }
      this.stopRevealAnimation();
      return;
    }

    // Create or reuse container
    if (!this.subtitleContainer || !this.overlayElement.contains(this.subtitleContainer)) {
      while (this.overlayElement.firstChild) {
        this.overlayElement.removeChild(this.overlayElement.firstChild);
      }

      this.subtitleContainer = document.createElement('div');
      this.subtitleContainer.className = 'ai-subtitle-text';
      this.applyStylesToElement(this.subtitleContainer);

      this.originalSpan = document.createElement('span');
      this.originalSpan.className = 'ai-subtitle-original';
      this.subtitleContainer.appendChild(this.originalSpan);

      this.translatedSpan = document.createElement('span');
      this.translatedSpan.className = 'ai-subtitle-translated';
      this.subtitleContainer.appendChild(this.translatedSpan);

      this.overlayElement.appendChild(this.subtitleContainer);
    }

    // Ensure container is visible
    this.subtitleContainer.style.opacity = '1';

    // Update original text
    if (this.originalSpan) {
      if (this.options.showOriginal && originalText) {
        this.originalSpan.textContent = originalText;
        this.originalSpan.style.display = 'block';
      } else {
        this.originalSpan.style.display = 'none';
      }
    }

    // Update translated text
    const textToShow = translatedText || originalText;

    if (triggerAnimation && this.progressiveRevealEnabled && textToShow.length > 0) {
      // Start smooth reveal animation
      // With shorter cues (max 3s, ~40 chars), use faster reveal
      // Reveal over 50% of cue duration, capped between 0.4s and 1.5s
      this.revealDuration = Math.max(400, Math.min(cueDuration * 0.5, 1500));
      this.revealStartTime = performance.now();
      this.currentRevealProgress = 0;

      // Store full text and start animation
      if (this.translatedSpan) {
        this.translatedSpan.dataset.fullText = textToShow;
        // Start with ~20% of text visible to avoid jarring empty-to-text transition
        const initialChars = Math.max(1, Math.floor(textToShow.length * 0.2));
        this.translatedSpan.textContent = textToShow.substring(0, initialChars);
      }

      this.startRevealAnimation();
    } else {
      // No animation - show full text immediately
      this.stopRevealAnimation();
      if (this.translatedSpan) {
        this.translatedSpan.textContent = textToShow;
        delete this.translatedSpan.dataset.fullText;
      }
    }
  }

  /**
   * Start the smooth reveal animation loop
   */
  private startRevealAnimation(): void {
    // Cancel any existing animation
    if (this.revealAnimationId !== null) {
      cancelAnimationFrame(this.revealAnimationId);
    }

    const animate = (currentTime: number): void => {
      if (!this.translatedSpan || !this.translatedSpan.dataset.fullText) {
        return;
      }

      const fullText = this.translatedSpan.dataset.fullText;
      const elapsed = currentTime - this.revealStartTime;

      // Calculate progress with smooth ease-out curve
      // Start from 20% (initial text shown) and animate to 100%
      const linearProgress = Math.min(1, elapsed / this.revealDuration);
      // Ease-out quadratic for smooth but faster deceleration
      const easedProgress = 1 - Math.pow(1 - linearProgress, 2);
      // Map from 0.2 to 1.0
      this.currentRevealProgress = 0.2 + (easedProgress * 0.8);

      // Calculate characters to show
      const charsToShow = Math.round(fullText.length * this.currentRevealProgress);

      // Update text content
      if (charsToShow >= fullText.length) {
        // Animation complete - show full text
        this.translatedSpan.textContent = fullText;
        delete this.translatedSpan.dataset.fullText;
        this.revealAnimationId = null;
        return;
      }

      // Show partial text
      this.translatedSpan.textContent = fullText.substring(0, charsToShow);

      // Continue animation
      this.revealAnimationId = requestAnimationFrame(animate);
    };

    this.revealAnimationId = requestAnimationFrame(animate);
  }

  /**
   * Stop the reveal animation
   */
  private stopRevealAnimation(): void {
    if (this.revealAnimationId !== null) {
      cancelAnimationFrame(this.revealAnimationId);
      this.revealAnimationId = null;
    }
    this.currentRevealProgress = 1;
  }
}

// ============================================================================
// Factory Function
// ============================================================================

export function createRealtimeTranslator(options: RealtimeTranslatorOptions): RealtimeTranslator {
  return new RealtimeTranslator(options);
}

export type { TranslatedCue, RealtimeTranslatorOptions };
