/**
 * Real-time Subtitle Translator
 * 
 * Two modes:
 * 1. Time-sync mode: Uses pre-translated cues synced to video time
 * 2. DOM observer mode: Monitors YouTube's subtitle DOM for changes
 */

import type { Platform } from '../shared/types/subtitle';
import type { RenderOptions } from './adapters/types';

// ============================================================================
// Types
// ============================================================================

interface TranslationCache {
  [sourceText: string]: string;
}

/** Pre-translated cue with timing info */
interface TranslatedCue {
  startTime: number;
  endTime: number;
  originalText: string;
  translatedText: string;
}

interface RealtimeTranslatorOptions {
  platform: Platform;
  targetLanguage: string;
  onTranslationRequest: (text: string) => Promise<string>;
  showOriginal?: boolean;
  hideNativeSubtitles?: boolean;
  /** Pre-translated cues for time-sync mode */
  translatedCues?: TranslatedCue[];
  /** Whether subtitles are auto-generated (ASR) - affects update frequency and progressive display */
  isAutoGenerated?: boolean;
  /** Render options for styling */
  renderOptions?: Partial<RenderOptions>;
  /**
   * Enable progressive text reveal for ASR subtitles.
   * When enabled, translated text is revealed character by character based on timing,
   * reducing the "time shift" perception when compared to YouTube's progressive ASR display.
   * Default: true for ASR subtitles, false for manual subtitles
   */
  progressiveReveal?: boolean;
}

type TranslatorState = 'idle' | 'active' | 'paused';

// ============================================================================
// Styles
// ============================================================================

const SUBTITLE_STYLES = `
  .ai-subtitle-overlay {
    position: absolute;
    bottom: 4%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2147483647;
    pointer-events: none;
    width: 90%;
    max-width: 1200px;
    text-align: center;
  }

  /* When native subtitles are visible, position our overlay higher to avoid overlap */
  .ai-subtitle-overlay.ai-subtitle-overlay-above-native {
    bottom: 15%;
  }

  .ai-subtitle-text {
    display: inline-block;
    padding: 16px 32px;
    border-radius: 8px;
    font-weight: 500;
    line-height: 1.5;
    max-width: 100%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    /* Default values - will be overridden by inline styles */
    background: rgba(0, 0, 0, 0.85);
    color: #fff;
    font-size: 28px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
  }

  .ai-subtitle-original {
    display: block;
    opacity: 0.75;
    margin-bottom: 8px;
    font-weight: 400;
  }

  .ai-subtitle-translated {
    display: block;
    font-weight: 600;
  }

  /* Hide YouTube native subtitles when our translator is active */
  .ai-subtitle-hide-native .ytp-caption-window-container,
  .ai-subtitle-hide-native .caption-window {
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* Hide Netflix native subtitles */
  .ai-subtitle-hide-netflix .player-timedtext,
  .ai-subtitle-hide-netflix .player-timedtext-text-container {
    display: none !important;
    visibility: hidden !important;
  }
`;

// ============================================================================
// Realtime Translator Class
// ============================================================================

export class RealtimeTranslator {
  private options: RealtimeTranslatorOptions;
  private cache: TranslationCache = {};
  private observer: MutationObserver | null = null;
  private state: TranslatorState = 'idle';
  private styleElement: HTMLStyleElement | null = null;
  private overlayElement: HTMLElement | null = null;
  private videoElement: HTMLVideoElement | null = null;
  private timeUpdateHandler: (() => void) | null = null;
  private seekHandler: (() => void) | null = null;
  private currentCueIndex: number = -1;
  private lastDisplayedText: string = '';
  private lastDisplayedCueStart: number = -1;  // Track which cue is displayed by its start time
  private lastUpdateTime: number = 0;
  private pendingTranslations: Map<string, Promise<string>> = new Map();
  private translateDebounceTimer: ReturnType<typeof setTimeout> | null = null;
  
  // Time offset in milliseconds (positive = subtitles are ahead, negative = subtitles are behind)
  private timeOffset: number = 0;
  private timeOffsetCalibrated: boolean = false;
  
  // Render options for styling
  private renderOptions: Partial<RenderOptions> = {};

  // Progressive reveal state for ASR subtitles
  private progressiveRevealEnabled: boolean = false;
  private lastProgressiveText: string = '';
  private lastProgressiveLength: number = 0;

  // Throttle interval for timeupdate (ms)
  // For ASR subtitles: use faster updates (100ms) for better sync with short segments
  // For manual subtitles: use slower updates (250ms) for performance
  // Reduced throttle intervals for faster subtitle updates with minimal delay
  private static readonly TIME_UPDATE_THROTTLE_NORMAL = 100;  // Was 250ms, now 100ms for faster response
  private static readonly TIME_UPDATE_THROTTLE_ASR = 50;       // Was 100ms, now 50ms for even faster ASR sync
  
  constructor(options: RealtimeTranslatorOptions) {
    // Determine hideNativeSubtitles from renderOptions if provided, otherwise use the direct option
    const hideNative = options.renderOptions?.hideNativeSubtitles ?? options.hideNativeSubtitles ?? true;

    // Build options with defaults first, then override with provided options
    const baseOptions = {
      showOriginal: true,
      hideNativeSubtitles: true,
      isAutoGenerated: false,
    };

    this.options = {
      ...baseOptions,
      ...options,
    };

    // Ensure hideNativeSubtitles respects the computed value (renderOptions takes precedence)
    this.options.hideNativeSubtitles = hideNative;

    // Enable progressive reveal by default for ASR subtitles
    // This reduces the perceived "time shift" between progressive ASR display and instant translation
    this.progressiveRevealEnabled = options.progressiveReveal ?? (options.isAutoGenerated ?? false);

    // NOTE: We keep the reference to the original translatedCues array
    // This allows the content script to update translations in-place
    // The caller is responsible for ensuring cues are sorted by startTime
    this.renderOptions = options.renderOptions || {};
  }
  
  /**
   * Get the appropriate throttle interval based on subtitle type
   */
  private getThrottleInterval(): number {
    return this.options.isAutoGenerated 
      ? RealtimeTranslator.TIME_UPDATE_THROTTLE_ASR 
      : RealtimeTranslator.TIME_UPDATE_THROTTLE_NORMAL;
  }
  
  /**
   * Set time offset for subtitle synchronization
   * @param offsetMs Offset in milliseconds (positive = delay subtitles, negative = advance subtitles)
   */
  setTimeOffset(offsetMs: number): void {
    this.timeOffset = offsetMs;
    this.timeOffsetCalibrated = true;
    console.log(`[RealtimeTranslator] Time offset set to ${offsetMs}ms`);
    // Force update with new offset
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Get current time offset
   */
  getTimeOffset(): number {
    return this.timeOffset;
  }
  
  /**
   * Force refresh the current cue display.
   * Call this after translations have been updated to show new translations immediately.
   */
  refreshCurrentCue(): void {
    if (this.state !== 'active' || !this.videoElement) {
      return;
    }
    // Reset display tracking to force re-render
    this.lastDisplayedText = '';
    this.lastDisplayedCueStart = -1;
    this.lastProgressiveLength = 0;
    // Trigger immediate update
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Update render options and re-apply styles
   */
  updateRenderOptions(options: Partial<RenderOptions>): void {
    this.renderOptions = { ...this.renderOptions, ...options };

    // Update showOriginal from bilingual setting
    if (options.bilingual !== undefined) {
      this.options.showOriginal = options.bilingual;
    }

    // Handle hideNativeSubtitles changes
    if (options.hideNativeSubtitles !== undefined) {
      this.options.hideNativeSubtitles = options.hideNativeSubtitles;
      if (options.hideNativeSubtitles) {
        this.hideNativeSubtitles();
        this.overlayElement?.classList.remove('ai-subtitle-overlay-above-native');
      } else {
        this.showNativeSubtitles();
        this.overlayElement?.classList.add('ai-subtitle-overlay-above-native');
      }
    }

    // Re-apply styles to overlay if it exists
    if (this.overlayElement) {
      this.applyRenderOptionsToOverlay();
    }

    // Force refresh to show changes
    this.refreshCurrentCue();

    console.log('[RealtimeTranslator] Render options updated:', options);
  }
  
  /**
   * Update the translated cues (used when uploading external translations)
   * NOTE: This replaces the cues array reference. For in-place updates during
   * background translation, modify the existing array elements directly.
   */
  updateTranslatedCues(cues: TranslatedCue[]): void {
    this.options.translatedCues = cues;
    console.log(`[RealtimeTranslator] Updated translated cues: ${cues.length} cues`);
  }
  
  /**
   * Apply render options to the overlay element
   */
  private applyRenderOptionsToOverlay(): void {
    if (!this.overlayElement) return;
    
    const opts = this.renderOptions;
    
    // Apply position to overlay container
    if (opts.position === 'top') {
      this.overlayElement.style.bottom = 'auto';
      this.overlayElement.style.top = '10%';
    } else {
      this.overlayElement.style.top = 'auto';
      this.overlayElement.style.bottom = '10%';
    }
    
    // Apply font settings to existing subtitle text elements
    const textElements = this.overlayElement.querySelectorAll('.ai-subtitle-text');
    textElements.forEach((el) => {
      this.applyStylesToElement(el as HTMLElement);
    });
  }
  
  /**
   * Auto-calibrate time offset by finding the first cue
   */
  private autoCalibrate(): void {
    if (this.timeOffsetCalibrated || !this.videoElement || !this.options.translatedCues) {
      return;
    }
    
    const cues = this.options.translatedCues;
    if (cues.length === 0) return;
    
    // Find the first cue's start time
    const firstCueStart = cues[0].startTime;
    
    // If first cue starts very late (> 30 seconds), it might indicate an offset issue
    // Netflix sometimes has credits/intro that aren't in subtitles
    if (firstCueStart > 30000) {
      console.log(`[RealtimeTranslator] First cue starts at ${firstCueStart}ms - may need offset adjustment`);
    }
    
    this.timeOffsetCalibrated = true;
  }
  
  /**
   * Start the translator
   */
  start(): void {
    if (this.state === 'active') {
      console.log('[RealtimeTranslator] Already active');
      return;
    }
    
    console.log('[RealtimeTranslator] Starting...');
    this.state = 'active';
    
    // Inject styles
    this.injectStyles();
    
    // Create overlay
    this.createOverlay();
    
    // Hide native subtitles
    if (this.options.hideNativeSubtitles) {
      this.hideNativeSubtitles();
    }
    
    // Choose mode based on whether we have pre-translated cues
    if (this.options.translatedCues && this.options.translatedCues.length > 0) {
      console.log('[RealtimeTranslator] Using time-sync mode with', this.options.translatedCues.length, 'cues');
      this.startTimeSyncMode();
    } else {
      console.log('[RealtimeTranslator] Using DOM observer mode');
      this.startObserverMode();
    }
  }
  
  /**
   * Stop the translator
   */
  stop(): void {
    console.log('[RealtimeTranslator] Stopping...');
    this.state = 'idle';
    
    // Stop time sync
    this.stopTimeSyncMode();
    
    // Stop observer
    this.stopObserverMode();
    
    // Clear debounce timer
    if (this.translateDebounceTimer) {
      clearTimeout(this.translateDebounceTimer);
      this.translateDebounceTimer = null;
    }
    
    // Show native subtitles again
    this.showNativeSubtitles();
    
    // Remove overlay
    this.removeOverlay();
    
    // Remove styles
    this.removeStyles();
    
    // Clear state
    this.pendingTranslations.clear();
    this.currentCueIndex = -1;
    this.lastDisplayedText = '';
    this.lastDisplayedCueStart = -1;
    this.lastProgressiveLength = 0;
    this.cache = {};
  }
  
  /**
   * Get current state
   */
  getState(): TranslatorState {
    return this.state;
  }
  
  // ============================================================================
  // Time-Sync Mode (for pre-translated subtitles)
  // ============================================================================
  
  private startTimeSyncMode(): void {
    // Find video element
    this.videoElement = document.querySelector('video');
    if (!this.videoElement) {
      console.warn('[RealtimeTranslator] Video element not found');
      return;
    }
    
    // Throttled handler for regular time updates (performance optimization)
    this.timeUpdateHandler = () => this.onTimeUpdateThrottled();
    
    // Immediate handler for seek events (responsive UX)
    this.seekHandler = () => this.onTimeUpdateImmediate();
    
    // Regular time updates - throttled for performance
    this.videoElement.addEventListener('timeupdate', this.timeUpdateHandler);
    
    // Seek events - immediate response for good UX
    this.videoElement.addEventListener('seeking', this.seekHandler);
    this.videoElement.addEventListener('seeked', this.seekHandler);
    this.videoElement.addEventListener('playing', this.seekHandler);
    this.videoElement.addEventListener('play', this.seekHandler);
    
    // Immediately update to current position
    this.onTimeUpdateImmediate();
    
    console.log('[RealtimeTranslator] Time-sync mode started');
  }
  
  private stopTimeSyncMode(): void {
    if (this.videoElement) {
      if (this.timeUpdateHandler) {
        this.videoElement.removeEventListener('timeupdate', this.timeUpdateHandler);
      }
      if (this.seekHandler) {
        this.videoElement.removeEventListener('seeking', this.seekHandler);
        this.videoElement.removeEventListener('seeked', this.seekHandler);
        this.videoElement.removeEventListener('playing', this.seekHandler);
        this.videoElement.removeEventListener('play', this.seekHandler);
      }
    }
    this.videoElement = null;
    this.timeUpdateHandler = null;
    this.seekHandler = null;
  }
  
  /**
   * Throttled time update - called frequently but only processes every N ms
   * Uses faster throttle for ASR subtitles to maintain sync with short segments
   */
  private onTimeUpdateThrottled(): void {
    const now = Date.now();
    const throttleInterval = this.getThrottleInterval();
    if (now - this.lastUpdateTime < throttleInterval) {
      return; // Skip this update
    }
    this.lastUpdateTime = now;
    this.onTimeUpdateImmediate();
  }
  
  /**
   * Immediate time update - for seek events and initial load
   */
  private onTimeUpdateImmediate(): void {
    if (this.state !== 'active' || !this.videoElement || !this.options.translatedCues) {
      return;
    }

    // Auto-calibrate on first update
    this.autoCalibrate();

    // Apply time offset: subtract offset from video time to match subtitle time
    // If subtitles are ahead (showing too early), use positive offset
    // If subtitles are behind (showing too late), use negative offset
    const currentTime = (this.videoElement.currentTime * 1000) - this.timeOffset;
    const cues = this.options.translatedCues;

    // Use binary search for better performance with large cue lists
    const activeCue = this.findActiveCue(cues, currentTime);

    // Update display if cue changed
    if (activeCue) {
      // Check if this cue hasn't been translated yet (translation equals original)
      const needsTranslation = activeCue.translatedText === activeCue.originalText &&
                               activeCue.originalText.trim().length > 0;

      if (needsTranslation) {
        // Trigger on-demand translation for the current cue
        this.translateCurrentCueOnDemand(activeCue);
      }

      // For ASR subtitles with progressive reveal enabled, calculate how much text to show
      // based on the current position within the cue's time range
      let displayTranslation = activeCue.translatedText;
      let displayOriginal = activeCue.originalText;

      if (this.progressiveRevealEnabled && this.options.isAutoGenerated) {
        const { revealedTranslation, revealedOriginal } = this.calculateProgressiveReveal(
          activeCue,
          currentTime
        );
        displayTranslation = revealedTranslation;
        displayOriginal = revealedOriginal;
      }

      // Update display if:
      // 1. The text has changed, OR
      // 2. We're on a different cue (different start time) even if text is the same
      // 3. Progressive reveal text length changed
      // This ensures consecutive cues with identical text still trigger updates
      const cueChanged = activeCue.startTime !== this.lastDisplayedCueStart;
      const textChanged = displayTranslation !== this.lastDisplayedText;
      const progressiveChanged = this.progressiveRevealEnabled &&
        displayTranslation.length !== this.lastProgressiveLength;

      if (textChanged || cueChanged || progressiveChanged) {
        this.lastDisplayedText = displayTranslation;
        this.lastDisplayedCueStart = activeCue.startTime;
        this.lastProgressiveLength = displayTranslation.length;
        this.updateOverlay(displayOriginal, displayTranslation);
      }
    } else {
      // No active cue, clear display
      if (this.lastDisplayedText !== '' || this.lastDisplayedCueStart !== -1) {
        this.lastDisplayedText = '';
        this.lastDisplayedCueStart = -1;
        this.lastProgressiveLength = 0;
        this.clearOverlay();
      }
    }
  }

  /**
   * Translate the current cue on-demand if it hasn't been translated yet.
   * This ensures the user always sees a translation for what they're currently watching,
   * even if the batch translation hasn't reached this cue yet.
   */
  private translateCurrentCueOnDemand(cue: TranslatedCue): void {
    const text = cue.originalText.trim();

    // Skip if already pending or recently attempted
    if (this.pendingTranslations.has(text)) {
      return;
    }

    // Request translation via the callback
    const promise = this.options.onTranslationRequest(text)
      .then(result => {
        // Update the cue with the translation
        if (result && result !== text) {
          cue.translatedText = result;
          this.cache[text] = result;

          // Immediately refresh display to show the new translation
          if (this.state === 'active') {
            this.lastDisplayedText = ''; // Force refresh
            this.lastDisplayedCueStart = -1; // Also reset cue tracking
            this.lastProgressiveLength = 0; // Reset progressive reveal
            this.onTimeUpdateImmediate();
          }
        }
        this.pendingTranslations.delete(text);
        return result;
      })
      .catch(error => {
        console.error('[RealtimeTranslator] On-demand translation error:', error);
        this.pendingTranslations.delete(text);
        throw error;
      });

    this.pendingTranslations.set(text, promise);
  }
  
  /**
   * Calculate progressive text reveal for ASR subtitles.
   * This reveals the translation character by character based on progress through the cue,
   * reducing the perception of "time shift" compared to YouTube's progressive ASR display.
   *
   * The reveal strategy:
   * - 0-10% of cue duration: Show first 30% of text (quick start for context)
   * - 10-90% of cue duration: Linearly reveal remaining 70% of text
   * - 90-100% of cue duration: Show full text
   *
   * This creates a reading experience that feels synchronized with speech.
   */
  private calculateProgressiveReveal(
    cue: TranslatedCue,
    currentTime: number
  ): { revealedTranslation: string; revealedOriginal: string } {
    const fullTranslation = cue.translatedText;
    const fullOriginal = cue.originalText;
    const duration = cue.endTime - cue.startTime;

    // Edge case: very short or zero duration
    if (duration <= 0) {
      return { revealedTranslation: fullTranslation, revealedOriginal: fullOriginal };
    }

    // Calculate progress through the cue (0.0 to 1.0)
    const elapsed = currentTime - cue.startTime;
    const progress = Math.max(0, Math.min(1, elapsed / duration));

    // Quick reveal strategy:
    // - First 10% of time: reveal 30% of text (immediate context)
    // - 10-90% of time: linearly reveal remaining 70%
    // - Last 10%: full text shown
    let revealRatio: number;
    if (progress <= 0.1) {
      // Quick start: show 30% at 10% time progress
      revealRatio = 0.3 * (progress / 0.1);
    } else if (progress >= 0.9) {
      // End: show all text
      revealRatio = 1;
    } else {
      // Middle: linear reveal from 30% to 100%
      const middleProgress = (progress - 0.1) / 0.8; // Normalize 0.1-0.9 to 0-1
      revealRatio = 0.3 + (0.7 * middleProgress);
    }

    // Calculate characters to show (use character-based for CJK text)
    const translationLength = Math.ceil(fullTranslation.length * revealRatio);
    const originalLength = Math.ceil(fullOriginal.length * revealRatio);

    // Reveal text, preferring word boundaries when possible for non-CJK text
    const revealedTranslation = this.revealTextProgressively(fullTranslation, translationLength);
    const revealedOriginal = this.revealTextProgressively(fullOriginal, originalLength);

    return { revealedTranslation, revealedOriginal };
  }

  /**
   * Reveal text progressively up to the target length.
   * For CJK text, reveals character by character.
   * For Latin text, tries to reveal at word boundaries.
   */
  private revealTextProgressively(text: string, targetLength: number): string {
    if (targetLength >= text.length) {
      return text;
    }

    // Check if text contains CJK characters (Chinese, Japanese, Korean)
    const hasCJK = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(text);

    if (hasCJK) {
      // For CJK text, reveal character by character
      return text.substring(0, targetLength);
    }

    // For Latin text, try to reveal at word boundaries
    const words = text.split(/(\s+)/); // Split keeping whitespace
    let revealed = '';
    let currentLength = 0;

    for (const word of words) {
      if (currentLength + word.length <= targetLength) {
        revealed += word;
        currentLength += word.length;
      } else if (currentLength === 0) {
        // At least show partial first word
        revealed = word.substring(0, targetLength);
        break;
      } else {
        break;
      }
    }

    return revealed;
  }

  /**
   * Find active cue using linear search for reliability
   * Linear search is more reliable when cues may have overlapping times or gaps
   * For typical subtitle files (~500 cues), performance is acceptable
   *
   * For ASR subtitles, we use an intelligent "grace period" approach:
   * - If currentTime is within a cue's time range, return that cue
   * - If currentTime is in a gap between cues:
   *   - For short gaps (≤1000ms): extend previous cue display for up to 500ms
   *   - For medium gaps (≤2000ms): extend previous cue for up to 300ms
   *   - For longer gaps: show nothing (natural pause in speech)
   *
   * This handles the varying gap lengths that occur after ASR consolidation,
   * where sentence boundaries often create longer pauses than word boundaries.
   */
  private findActiveCue(cues: TranslatedCue[], currentTime: number): TranslatedCue | null {
    if (cues.length === 0) return null;

    // First pass: find exact match
    for (const cue of cues) {
      if (currentTime >= cue.startTime && currentTime < cue.endTime) {
        return cue;
      }
    }

    // Second pass: handle gaps between cues for smoother display
    // This prevents subtitle "flicker" during small time gaps in ASR content
    for (let i = 0; i < cues.length - 1; i++) {
      const currentCue = cues[i];
      const nextCue = cues[i + 1];
      const gapStart = currentCue.endTime;
      const gapEnd = nextCue.startTime;

      // Check if currentTime is in the gap between two cues
      if (currentTime >= gapStart && currentTime < gapEnd) {
        const gapDuration = gapEnd - gapStart;
        const timeIntoGap = currentTime - gapStart;

        // Determine grace period based on gap duration
        // Shorter gaps get longer grace periods (smoother viewing)
        // Longer gaps get shorter grace periods (natural speech pauses)
        let gracePeriod: number;
        if (gapDuration <= 1000) {
          // Short gap: likely brief pause within sentence, extend up to 500ms
          gracePeriod = 500;
        } else if (gapDuration <= 2000) {
          // Medium gap: likely sentence boundary, extend up to 300ms
          gracePeriod = 300;
        } else {
          // Long gap: intentional pause, don't extend (show nothing)
          gracePeriod = 0;
        }

        // If we're within the grace period, show the previous cue
        if (gracePeriod > 0 && timeIntoGap <= gracePeriod) {
          return currentCue;
        }
        // Otherwise, show nothing (let next cue appear naturally)
        break;
      }
    }

    return null;
  }
  
  // ============================================================================
  // DOM Observer Mode (fallback for real-time translation)
  // ============================================================================
  
  private startObserverMode(): void {
    const container = this.findCaptionContainer();
    
    if (!container) {
      console.log('[RealtimeTranslator] Caption container not found, will retry...');
      setTimeout(() => {
        if (this.state === 'active') {
          this.startObserverMode();
        }
      }, 1000);
      return;
    }
    
    console.log('[RealtimeTranslator] Caption container found');
    
    this.observer = new MutationObserver(() => {
      if (this.state === 'active') {
        this.onSubtitleChange();
      }
    });
    
    this.observer.observe(container, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }
  
  private stopObserverMode(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }
  
  private findCaptionContainer(): Element | null {
    const selectors = [
      '.ytp-caption-window-container',
      '.caption-window',
      '#movie_player .ytp-caption-window-container',
    ];
    
    for (const selector of selectors) {
      const container = document.querySelector(selector);
      if (container) return container;
    }
    
    return null;
  }
  
  private onSubtitleChange(): void {
    const container = this.findCaptionContainer();
    if (!container) return;
    
    // Get text from caption segments
    const segments = container.querySelectorAll('.ytp-caption-segment');
    let fullText = '';
    
    if (segments.length > 0) {
      fullText = Array.from(segments)
        .map(s => s.textContent?.trim())
        .filter(Boolean)
        .join(' ');
    }
    
    // Clean and validate text
    fullText = this.cleanSubtitleText(fullText);
    if (!fullText || fullText === this.lastDisplayedText || fullText.length < 2) {
      return;
    }
    
    this.lastDisplayedText = fullText;
    this.debounceTranslate(fullText);
  }
  
  private debounceTranslate(text: string): void {
    if (this.translateDebounceTimer) {
      clearTimeout(this.translateDebounceTimer);
    }
    
    // Show original immediately
    this.updateOverlay(text, '', true);
    
    this.translateDebounceTimer = setTimeout(() => {
      void this.doTranslate(text);
    }, 300);
  }
  
  private async doTranslate(text: string): Promise<void> {
    if (text !== this.lastDisplayedText) return;
    
    try {
      const translation = await this.translateText(text);
      if (text === this.lastDisplayedText && this.state === 'active') {
        this.updateOverlay(text, translation);
      }
    } catch (error) {
      console.error('[RealtimeTranslator] Translation error:', error);
    }
  }
  
  private async translateText(text: string): Promise<string> {
    // Check cache
    if (this.cache[text]) {
      return this.cache[text];
    }
    
    // Check pending
    if (this.pendingTranslations.has(text)) {
      return this.pendingTranslations.get(text)!;
    }
    
    const promise = this.options.onTranslationRequest(text)
      .then(result => {
        this.cache[text] = result;
        this.pendingTranslations.delete(text);
        return result;
      })
      .catch(error => {
        this.pendingTranslations.delete(text);
        throw error;
      });
    
    this.pendingTranslations.set(text, promise);
    return promise;
  }
  
  private cleanSubtitleText(text: string): string {
    const patterns = [
      /日文\s*\(自動產生\)/g,
      /英文\s*\(自動產生\)/g,
      /中文\s*\(自動產生\)/g,
      /\(自動產生\)/g,
      /按一下.*$/g,
      /點擊.*$/g,
      /Auto-generated/gi,
    ];
    
    let cleaned = text;
    for (const pattern of patterns) {
      cleaned = cleaned.replace(pattern, '');
    }
    
    return cleaned.trim();
  }
  
  // ============================================================================
  // UI Methods
  // ============================================================================
  
  private injectStyles(): void {
    if (this.styleElement) return;
    
    this.styleElement = document.createElement('style');
    this.styleElement.id = 'ai-subtitle-translator-styles';
    this.styleElement.textContent = SUBTITLE_STYLES;
    document.head.appendChild(this.styleElement);
  }
  
  private removeStyles(): void {
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  
  private createOverlay(): void {
    if (this.overlayElement) return;
    
    // Platform-specific player selectors
    const playerSelectors = [
      // YouTube
      '#movie_player',
      '.html5-video-player',
      // Netflix
      '.watch-video--player-view',
      '.VideoContainer',
      '[data-uia="video-canvas"]',
      // Disney+
      '.btm-media-client-element',
      // Prime Video
      '.webPlayerContainer',
      '.dv-player-fullscreen',
      // Generic fallback
      'video',
    ];
    
    let player: Element | null = null;
    for (const selector of playerSelectors) {
      player = document.querySelector(selector);
      if (player) {
        console.log('[RealtimeTranslator] Found player container:', selector);
        break;
      }
    }
    
    if (!player) {
      console.warn('[RealtimeTranslator] Video player not found, using body as fallback');
      player = document.body;
    }
    
    // For video element, use its parent
    if (player.tagName === 'VIDEO') {
      player = player.parentElement || document.body;
    }
    
    this.overlayElement = document.createElement('div');
    this.overlayElement.className = 'ai-subtitle-overlay';
    this.overlayElement.id = 'ai-subtitle-overlay';

    // If native subtitles are NOT hidden, position our overlay higher to avoid overlap
    // This allows users to see both native progressive subtitles and our translation
    if (!this.options.hideNativeSubtitles) {
      this.overlayElement.classList.add('ai-subtitle-overlay-above-native');
      console.log('[RealtimeTranslator] Native subtitles visible, positioning overlay above');
    }

    // Ensure parent has position for absolute positioning
    const computedStyle = window.getComputedStyle(player);
    if (computedStyle.position === 'static') {
      (player as HTMLElement).style.position = 'relative';
    }

    player.appendChild(this.overlayElement);
    console.log('[RealtimeTranslator] Overlay created and attached');
  }
  
  private removeOverlay(): void {
    if (this.overlayElement) {
      this.overlayElement.remove();
      this.overlayElement = null;
    }
  }
  
  private hideNativeSubtitles(): void {
    // YouTube
    const ytPlayer = document.querySelector('#movie_player, .html5-video-player');
    if (ytPlayer) {
      ytPlayer.classList.add('ai-subtitle-hide-native');
    }
    
    // Netflix - hide the native subtitle container with multiple methods for reliability
    const netflixSelectors = [
      '.player-timedtext',
      '.player-timedtext-text-container',
      '[data-uia="player"]  .player-timedtext',
    ];
    
    for (const selector of netflixSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        (el as HTMLElement).style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
      });
    }
    
    // Also add class to body for CSS-based hiding
    document.body.classList.add('ai-subtitle-hide-netflix');
  }
  
  private showNativeSubtitles(): void {
    // YouTube
    const ytPlayer = document.querySelector('#movie_player, .html5-video-player');
    if (ytPlayer) {
      ytPlayer.classList.remove('ai-subtitle-hide-native');
    }
    
    // Netflix - restore native subtitles
    const netflixSelectors = [
      '.player-timedtext',
      '.player-timedtext-text-container',
      '[data-uia="player"] .player-timedtext',
    ];
    
    for (const selector of netflixSelectors) {
      const elements = document.querySelectorAll(selector);
      elements.forEach(el => {
        (el as HTMLElement).style.cssText = '';
      });
    }
    
    document.body.classList.remove('ai-subtitle-hide-netflix');
  }
  
  private updateOverlay(originalText: string, translatedText: string, isLoading: boolean = false): void {
    if (!this.overlayElement) {
      console.warn('[RealtimeTranslator] updateOverlay called but overlay not created');
      // Try to create it now
      this.createOverlay();
      if (!this.overlayElement) {
        console.error('[RealtimeTranslator] Failed to create overlay');
        return;
      }
    }
    
    // Clear
    while (this.overlayElement.firstChild) {
      this.overlayElement.removeChild(this.overlayElement.firstChild);
    }
    
    if (!translatedText && !originalText) return;
    
    const container = document.createElement('div');
    container.className = 'ai-subtitle-text';
    
    // Apply render options to container
    this.applyStylesToElement(container);
    
    if (this.options.showOriginal && originalText) {
      const originalSpan = document.createElement('span');
      originalSpan.className = 'ai-subtitle-original';
      originalSpan.textContent = originalText;
      container.appendChild(originalSpan);
    }
    
    const translatedSpan = document.createElement('span');
    translatedSpan.className = 'ai-subtitle-translated';
    translatedSpan.textContent = isLoading ? '翻譯中...' : (translatedText || originalText);
    container.appendChild(translatedSpan);
    
    this.overlayElement.appendChild(container);
  }
  
  /**
   * Apply current render options to a subtitle element
   */
  private applyStylesToElement(element: HTMLElement): void {
    const opts = this.renderOptions;
    
    // Font size - apply to container
    if (opts.fontSize !== undefined) {
      element.style.fontSize = `${opts.fontSize}px`;
    }
    
    // Font family
    if (opts.fontFamily !== undefined) {
      element.style.fontFamily = opts.fontFamily;
    }
    
    // Font color
    if (opts.fontColor !== undefined) {
      element.style.color = opts.fontColor;
    }
    
    // Apply background style
    if (opts.background === 'none') {
      element.style.background = 'transparent';
      element.style.boxShadow = 'none';
      element.style.padding = '8px 16px';
      // For "none" background, use outline text for readability
      element.style.textShadow = `-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 
                                   -2px 0 0 #000, 2px 0 0 #000, 0 -2px 0 #000, 0 2px 0 #000`;
    } else if (opts.background === 'shadow') {
      element.style.background = 'transparent';
      element.style.boxShadow = 'none';
      element.style.padding = '8px 16px';
      element.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.9), 0 0 8px rgba(0, 0, 0, 0.8)';
    } else if (opts.background === 'box') {
      element.style.background = 'rgba(0, 0, 0, 0.85)';
      element.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
      element.style.padding = '16px 32px';
      element.style.textShadow = 'none';
    }
  }
  
  private clearOverlay(): void {
    if (this.overlayElement) {
      while (this.overlayElement.firstChild) {
        this.overlayElement.removeChild(this.overlayElement.firstChild);
      }
    }
  }
}

// ============================================================================
// Factory Function
// ============================================================================

export function createRealtimeTranslator(options: RealtimeTranslatorOptions): RealtimeTranslator {
  return new RealtimeTranslator(options);
}

export type { TranslatedCue, RealtimeTranslatorOptions };
