/**
 * YouTube Platform Adapter
 *
 * Implements subtitle interception and injection for YouTube videos.
 * Uses XHR/fetch override to capture timedtext API requests.
 *
 * @see specs/001-ai-subtitle-translator/contracts/platform-adapter.md
 * @see specs/001-ai-subtitle-translator/research.md - YouTube subtitle interception
 */

import type { Cue, Platform, SubtitleFormat } from '../../shared/types/subtitle';
import type {
  PlatformAdapter,
  URLPattern,
  SubtitleTrack,
  RawSubtitle,
  RenderOptions,
  VideoEventCallback,
  VideoEvent,
} from './types';
import { DEFAULT_RENDER_OPTIONS, AdapterError } from './types';
import { createSubtitleRenderer, SubtitleRenderer } from '../subtitle-renderer';
import { createLogger } from '../../shared/utils/logger';

// Create logger for this module
const log = createLogger('YouTubeAdapter');

// ============================================================================
// Types
// ============================================================================

interface CapturedSubtitle {
  url: string;
  language: string;
  label: string;
  format: SubtitleFormat;
  isAutoGenerated: boolean;
  content?: string;  // Captured response body
}

interface PlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: Array<{
        baseUrl: string;
        vssId: string;
        languageCode: string;
        name: { simpleText?: string; runs?: Array<{ text: string }> };
        kind?: string;
        isTranslatable?: boolean;
      }>;
    };
  };
  videoDetails?: {
    videoId: string;
    title: string;
  };
}

// ============================================================================
// YouTube Adapter Implementation
// ============================================================================

/**
 * YouTube Platform Adapter
 */
export class YouTubeAdapter implements PlatformAdapter {
  readonly platform: Platform = 'youtube';
  
  readonly urlPatterns: URLPattern[] = [
    { pattern: /^https?:\/\/(?:www\.)?youtube\.com\/watch/, type: 'main' },
    { pattern: /^https?:\/\/(?:www\.)?youtube\.com\/embed\//, type: 'embed' },
    { pattern: /^https?:\/\/youtu\.be\//, type: 'main' },
  ];
  
  private capturedSubtitles: Map<string, CapturedSubtitle> = new Map();
  private videoElement: HTMLVideoElement | null = null;
  private renderer: SubtitleRenderer | null = null;
  private eventCallbacks: Set<VideoEventCallback> = new Set();
  private playerResponse: PlayerResponse | null = null;
  private initialized = false;
  private originalXHROpen: typeof XMLHttpRequest.prototype.open | null = null;
  private originalFetch: typeof window.fetch | null = null;
  private mutationObserver: MutationObserver | null = null;
  
  /**
   * Check if this adapter can handle the given URL
   */
  canHandle(url: string): boolean {
    return this.urlPatterns.some(p => p.pattern.test(url));
  }
  
  /**
   * Initialize the adapter
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }
    
    log.info('Initializing...');

    // Setup XHR/fetch interception
    this.setupInterception();

    // Extract player response from page
    this.extractPlayerResponse();

    // Setup video element observer
    this.observeVideoElement();

    this.initialized = true;
    log.info('Initialized successfully');
  }
  
  /**
   * Get current video ID from URL
   */
  getVideoId(): string | null {
    const url = new URL(window.location.href);
    
    // Standard watch URL
    if (url.pathname === '/watch') {
      return url.searchParams.get('v');
    }
    
    // Embed URL
    const embedMatch = url.pathname.match(/\/embed\/([^/?]+)/);
    if (embedMatch) {
      return embedMatch[1];
    }
    
    // youtu.be short URL
    if (url.hostname === 'youtu.be') {
      return url.pathname.slice(1).split('/')[0] || null;
    }
    
    // Try to get from player response
    return this.playerResponse?.videoDetails?.videoId ?? null;
  }
  
  /**
   * Get available subtitle tracks
   */
  async getSubtitleTracks(): Promise<SubtitleTrack[]> {
    const tracks: SubtitleTrack[] = [];
    
    // Get from player response (most reliable)
    if (this.playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks) {
      const captionTracks = this.playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;
      
      for (const track of captionTracks) {
        const label = track.name.simpleText || 
          track.name.runs?.map(r => r.text).join('') || 
          track.languageCode;
        
        tracks.push({
          id: track.vssId,
          language: track.languageCode,
          label,
          url: track.baseUrl,
          format: this.detectFormat(track.baseUrl),
          isAutoGenerated: track.kind === 'asr',
          isDefault: tracks.length === 0,
        });
      }
    }
    
    // Fallback: Get from captured requests
    if (tracks.length === 0) {
      for (const [id, subtitle] of this.capturedSubtitles) {
        tracks.push({
          id,
          language: subtitle.language,
          label: subtitle.label,
          url: subtitle.url,
          format: subtitle.format,
          isAutoGenerated: subtitle.isAutoGenerated,
          isDefault: tracks.length === 0,
        });
      }
    }
    
    log.info(`Found ${tracks.length} subtitle tracks`);
    return tracks;
  }
  
  /**
   * Fetch subtitle content
   */
  async fetchSubtitle(track: SubtitleTrack): Promise<RawSubtitle> {
    log.info(`Fetching subtitle: ${track.language}`);
    
    // First, check if we have captured content for this track
    const capturedId = `${track.language}-${track.isAutoGenerated ? 'asr' : 'manual'}`;
    const captured = this.capturedSubtitles.get(capturedId);
    
    if (captured?.content && captured.content.length > 0) {
      log.info(`Using captured content for ${track.language}`, { length: captured.content.length });
      return {
        content: captured.content,
        format: this.detectFormatFromContent(captured.content),
        metadata: {
          videoId: this.getVideoId(),
          language: track.language,
          isAutoGenerated: track.isAutoGenerated,
        },
      };
    }
    
    // Try to find any captured subtitle with content (user may want to translate from different language)
    for (const [, subtitle] of this.capturedSubtitles) {
      if (subtitle.content && subtitle.content.length > 0) {
        log.info(`Using available captured content`, {
          from: subtitle.language,
          requested: track.language,
          length: subtitle.content.length,
        });
        return {
          content: subtitle.content,
          format: this.detectFormatFromContent(subtitle.content),
          metadata: {
            videoId: this.getVideoId(),
            language: subtitle.language,  // Use the actual captured language
            isAutoGenerated: subtitle.isAutoGenerated,
          },
        };
      }
    }
    
    // Fallback: fetch from URL (may not work due to token expiration)
    let url = track.url;
    if (!url.includes('fmt=')) {
      url += (url.includes('?') ? '&' : '?') + 'fmt=json3';
    }
    
    log.info('No captured content, fetching from URL', { url });
    
    try {
      // Use the original fetch to avoid interception issues
      const fetchFn = this.originalFetch || window.fetch;
      const response = await fetchFn.call(window, url, {
        credentials: 'include',
      });
      
      log.info('Fetch response', {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
      });
      
      if (!response.ok) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          `Failed to fetch subtitle: ${response.status} ${response.statusText}`,
          this.platform
        );
      }
      
      const content = await response.text();
      log.info('Content received', {
        length: content.length,
        preview: content.substring(0, 200),
      });
      
      if (content.length === 0) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          'Subtitle content is empty. The subtitle may have already been loaded. Please refresh the page and try again.',
          this.platform
        );
      }
      
      const format = this.detectFormatFromContent(content);
      
      return {
        content,
        format,
        metadata: {
          videoId: this.getVideoId(),
          language: track.language,
          isAutoGenerated: track.isAutoGenerated,
        },
      };
    } catch (error) {
      if (error instanceof AdapterError) {
        throw error;
      }
      throw new AdapterError(
        'SUBTITLE_FETCH_FAILED',
        `Failed to fetch subtitle: ${error instanceof Error ? error.message : 'Unknown error'}`,
        this.platform
      );
    }
  }
  
  /**
   * Inject translated subtitles
   */
  injectSubtitles(cues: Cue[], options: RenderOptions = DEFAULT_RENDER_OPTIONS): void {
    if (!this.videoElement) {
      log.warn('No video element found');
      return;
    }
    
    if (!this.renderer) {
      this.renderer = createSubtitleRenderer();
    }
    
    this.renderer.attach(this.videoElement);
    this.renderer.setSubtitles(cues, options);
    this.renderer.setVisible(true);
    
    log.info(`Injected ${cues.length} subtitles`);
  }
  
  /**
   * Remove injected subtitles
   */
  removeSubtitles(): void {
    if (this.renderer) {
      this.renderer.detach();
      this.renderer = null;
    }
  }
  
  /**
   * Get video element
   */
  getVideoElement(): HTMLVideoElement | null {
    return this.videoElement;
  }
  
  /**
   * Subscribe to video events
   */
  onVideoEvent(callback: VideoEventCallback): () => void {
    this.eventCallbacks.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.eventCallbacks.delete(callback);
    };
  }
  
  /**
   * Clean up
   */
  destroy(): void {
    log.info('Destroying...');

    // Remove subtitles
    this.removeSubtitles();

    // Restore original XHR/fetch
    this.restoreInterception();

    // Disconnect mutation observer to prevent memory leaks
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }

    // Clear state
    this.capturedSubtitles.clear();
    this.eventCallbacks.clear();
    this.videoElement = null;
    this.playerResponse = null;
    this.initialized = false;
  }
  
  // ============================================================================
  // Private Methods
  // ============================================================================
  
  /**
   * Setup XHR/fetch interception for timedtext API
   */
  private setupInterception(): void {
    // Store originals
    this.originalXHROpen = XMLHttpRequest.prototype.open;
    this.originalFetch = window.fetch;

    const adapter = this;

    // Override XHR
    XMLHttpRequest.prototype.open = function(
      method: string,
      url: string | URL,
      async?: boolean,
      username?: string | null,
      password?: string | null
    ): void {
      // Safety check: if originalXHROpen is gone, we can't proceed safely
      const xhrOpen = adapter.originalXHROpen;
      if (!xhrOpen) {
        log.warn('XHR hook: originalXHROpen is null');
        return;
      }

      let urlString: string;
      try {
        urlString = url.toString();
      } catch {
        // If URL conversion fails, just call original
        return xhrOpen.call(
          this,
          method,
          url,
          async ?? true,
          username ?? null,
          password ?? null
        );
      }

      const xhr = this;

      // Capture timedtext requests with their response (wrap in try-catch)
      try {
        if (adapter.isTimedTextUrl(urlString)) {
          // Add load listener to capture response
          xhr.addEventListener('load', function() {
            try {
              const content = xhr.responseText || xhr.response;
              if (content && typeof content === 'string' && content.length > 0) {
                adapter.captureSubtitleWithContent(urlString, content);
              } else {
                adapter.captureSubtitleUrl(urlString);
              }
            } catch (error) {
              log.warn('Failed to capture XHR response', { error: String(error) });
              adapter.captureSubtitleUrl(urlString);
            }
          });
        }
      } catch (error) {
        log.warn('Failed to setup XHR capture listener', { error: String(error) });
      }

      // Call original
      return xhrOpen.call(
        this,
        method,
        url,
        async ?? true,
        username ?? null,
        password ?? null
      );
    };

    // Override fetch
    window.fetch = async function(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
      // Safety check: if originalFetch is gone, try to use the current window.fetch
      const fetchFn = adapter.originalFetch || window.fetch;

      let url: string;
      try {
        if (typeof input === 'string') {
          url = input;
        } else if (input instanceof URL) {
          url = input.toString();
        } else if (input instanceof Request) {
          url = input.url;
        } else {
          // Fallback for unexpected types
          url = String(input);
        }
      } catch {
        // If URL extraction fails, just pass through to original fetch
        return fetchFn.call(window, input, init);
      }

      // For timedtext requests, capture the response body
      try {
        if (adapter.isTimedTextUrl(url)) {
          const response = await fetchFn.call(window, input, init);

          // Clone the response so we can read the body and still return it
          const clonedResponse = response.clone();

          try {
            const content = await clonedResponse.text();
            adapter.captureSubtitleWithContent(url, content);
          } catch (error) {
            log.warn('Failed to capture subtitle content', { error: String(error) });
            adapter.captureSubtitleUrl(url);
          }

          return response;
        }
      } catch (error) {
        log.warn('Failed during timedtext capture', { error: String(error) });
      }

      return fetchFn.call(window, input, init);
    };

    log.info('XHR/fetch interception enabled');
  }
  
  /**
   * Restore original XHR/fetch
   */
  private restoreInterception(): void {
    if (this.originalXHROpen) {
      XMLHttpRequest.prototype.open = this.originalXHROpen;
      this.originalXHROpen = null;
    }
    
    if (this.originalFetch) {
      window.fetch = this.originalFetch;
      this.originalFetch = null;
    }
    
    log.info('XHR/fetch interception restored');
  }
  
  /**
   * Check if URL is a timedtext API request
   */
  private isTimedTextUrl(url: string): boolean {
    return url.includes('timedtext') || 
           url.includes('/api/timedtext') ||
           url.includes('youtube.com/api/timedtext');
  }
  
  /**
   * Capture subtitle URL from request (without content)
   */
  private captureSubtitleUrl(url: string): void {
    try {
      const urlObj = new URL(url);
      const lang = urlObj.searchParams.get('lang') || 'unknown';
      const name = urlObj.searchParams.get('name') || lang;
      const kind = urlObj.searchParams.get('kind') || '';
      
      const id = `${lang}-${kind || 'manual'}`;
      
      this.capturedSubtitles.set(id, {
        url,
        language: lang,
        label: name,
        format: this.detectFormat(url),
        isAutoGenerated: kind === 'asr',
      });
      
      log.info(`Captured subtitle URL: ${lang} (${kind || 'manual'})`);
    } catch (error) {
      log.warn('Failed to parse subtitle URL', { error: String(error) });
    }
  }
  
  /**
   * Capture subtitle URL with content from intercepted response
   */
  private captureSubtitleWithContent(url: string, content: string): void {
    try {
      const urlObj = new URL(url);
      const lang = urlObj.searchParams.get('lang') || 'unknown';
      const name = urlObj.searchParams.get('name') || lang;
      const kind = urlObj.searchParams.get('kind') || '';
      
      const id = `${lang}-${kind || 'manual'}`;
      
      this.capturedSubtitles.set(id, {
        url,
        language: lang,
        label: name,
        format: this.detectFormat(url),
        isAutoGenerated: kind === 'asr',
        content,  // Store the actual content
      });
      
      log.info(`Captured subtitle with content: ${lang} (${kind || 'manual'})`, { length: content.length });
    } catch (error) {
      log.warn('Failed to parse subtitle URL', { error: String(error) });
    }
  }
  
  /**
   * Extract player response from page
   */
  private extractPlayerResponse(): void {
    try {
      // Try to get from ytInitialPlayerResponse
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const text = script.textContent || '';
        
        // Look for ytInitialPlayerResponse
        const match = text.match(/ytInitialPlayerResponse\s*=\s*(\{.+?\});/);
        if (match) {
          try {
            this.playerResponse = JSON.parse(match[1]) as PlayerResponse;
            log.debug('Extracted player response from script');
            return;
          } catch {
            // Continue searching
          }
        }
      }
      
      // Try window object
      const windowAny = window as unknown as { ytInitialPlayerResponse?: PlayerResponse };
      if (windowAny.ytInitialPlayerResponse) {
        this.playerResponse = windowAny.ytInitialPlayerResponse;
        log.debug('Got player response from window');
      }
    } catch (error) {
      log.warn('Failed to extract player response', { error: String(error) });
    }
  }
  
  /**
   * Observe video element changes
   */
  private observeVideoElement(): void {
    // Disconnect any existing observer to prevent memory leaks
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }

    const findVideo = (): void => {
      const video = document.querySelector('video.html5-main-video') as HTMLVideoElement | null;

      if (video && video !== this.videoElement) {
        this.videoElement = video;
        this.setupVideoEventListeners(video);
        log.debug('Video element found');
      }
    };

    // Initial find
    findVideo();

    // Debounce the findVideo callback to prevent excessive calls
    // MutationObserver can fire hundreds of times per second
    let debounceTimer: ReturnType<typeof setTimeout> | null = null;
    const debouncedFindVideo = (): void => {
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        findVideo();
        debounceTimer = null;
      }, 100); // 100ms debounce
    };

    // Create and store observer for cleanup
    this.mutationObserver = new MutationObserver(() => {
      debouncedFindVideo();
    });

    // Only observe if body exists
    if (document.body) {
      this.mutationObserver.observe(document.body, {
        childList: true,
        subtree: true,
      });
    } else {
      // Wait for body to exist using setTimeout
      const waitForBody = (): void => {
        if (document.body && this.mutationObserver) {
          this.mutationObserver.observe(document.body, {
            childList: true,
            subtree: true,
          });
        } else if (!document.body) {
          setTimeout(waitForBody, 10);
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForBody);
      } else {
        setTimeout(waitForBody, 10);
      }
    }
  }
  
  /**
   * Setup event listeners on video element
   */
  private setupVideoEventListeners(video: HTMLVideoElement): void {
    const dispatchEvent = (event: VideoEvent): void => {
      for (const callback of this.eventCallbacks) {
        try {
          callback(event);
        } catch (error) {
          log.error('Event callback error', error instanceof Error ? error : { error });
        }
      }
    };
    
    video.addEventListener('play', () => dispatchEvent({ type: 'play' }));
    video.addEventListener('pause', () => dispatchEvent({ type: 'pause' }));
    video.addEventListener('ended', () => dispatchEvent({ type: 'ended' }));
    
    video.addEventListener('seeked', () => {
      dispatchEvent({ type: 'seeked', currentTime: video.currentTime });
    });
    
    video.addEventListener('timeupdate', () => {
      dispatchEvent({ type: 'timeupdate', currentTime: video.currentTime });
    });
    
    video.addEventListener('ratechange', () => {
      dispatchEvent({ type: 'ratechange', playbackRate: video.playbackRate });
    });
  }
  
  /**
   * Detect subtitle format from URL
   */
  private detectFormat(url: string): SubtitleFormat {
    if (url.includes('fmt=json3') || url.includes('fmt=srv3')) {
      return 'json3';
    }
    if (url.includes('fmt=vtt')) {
      return 'webvtt';
    }
    // Default to json3 for YouTube
    return 'json3';
  }
  
  /**
   * Detect format from content
   */
  private detectFormatFromContent(content: string): SubtitleFormat {
    const trimmed = content.trim();
    
    if (trimmed.startsWith('{')) {
      return 'json3';
    }
    if (trimmed.startsWith('WEBVTT')) {
      return 'webvtt';
    }
    if (trimmed.startsWith('<?xml') || trimmed.startsWith('<tt')) {
      return 'ttml';
    }
    
    return 'json3';
  }
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create a YouTube adapter instance
 */
export function createYouTubeAdapter(): YouTubeAdapter {
  return new YouTubeAdapter();
}
