/**
 * YouTube Platform Adapter
 * 
 * Implements subtitle interception and injection for YouTube videos.
 * Uses XHR/fetch override to capture timedtext API requests.
 * 
 * @see specs/001-ai-subtitle-translator/contracts/platform-adapter.md
 * @see specs/001-ai-subtitle-translator/research.md - YouTube subtitle interception
 */

import type { Cue, Platform, SubtitleFormat } from '../../shared/types/subtitle';
import type {
  PlatformAdapter,
  URLPattern,
  SubtitleTrack,
  RawSubtitle,
  RenderOptions,
  VideoEventCallback,
  VideoEvent,
} from './types';
import { DEFAULT_RENDER_OPTIONS, AdapterError } from './types';
import { createSubtitleRenderer, SubtitleRenderer } from '../subtitle-renderer';

// ============================================================================
// Types
// ============================================================================

interface CapturedSubtitle {
  url: string;
  language: string;
  label: string;
  format: SubtitleFormat;
  isAutoGenerated: boolean;
  content?: string;  // Captured response body
}

interface PlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: Array<{
        baseUrl: string;
        vssId: string;
        languageCode: string;
        name: { simpleText?: string; runs?: Array<{ text: string }> };
        kind?: string;
        isTranslatable?: boolean;
      }>;
    };
  };
  videoDetails?: {
    videoId: string;
    title: string;
  };
}

// ============================================================================
// YouTube Adapter Implementation
// ============================================================================

/**
 * YouTube Platform Adapter
 */
export class YouTubeAdapter implements PlatformAdapter {
  readonly platform: Platform = 'youtube';
  
  readonly urlPatterns: URLPattern[] = [
    { pattern: /^https?:\/\/(?:www\.)?youtube\.com\/watch/, type: 'main' },
    { pattern: /^https?:\/\/(?:www\.)?youtube\.com\/embed\//, type: 'embed' },
    { pattern: /^https?:\/\/youtu\.be\//, type: 'main' },
  ];
  
  private capturedSubtitles: Map<string, CapturedSubtitle> = new Map();
  private videoElement: HTMLVideoElement | null = null;
  private renderer: SubtitleRenderer | null = null;
  private eventCallbacks: Set<VideoEventCallback> = new Set();
  private playerResponse: PlayerResponse | null = null;
  private initialized = false;
  private originalXHROpen: typeof XMLHttpRequest.prototype.open | null = null;
  private originalFetch: typeof window.fetch | null = null;
  
  /**
   * Check if this adapter can handle the given URL
   */
  canHandle(url: string): boolean {
    return this.urlPatterns.some(p => p.pattern.test(url));
  }
  
  /**
   * Initialize the adapter
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }
    
    console.log('[YouTubeAdapter] Initializing...');
    
    // Setup XHR/fetch interception
    this.setupInterception();
    
    // Extract player response from page
    this.extractPlayerResponse();
    
    // Setup video element observer
    this.observeVideoElement();
    
    this.initialized = true;
    console.log('[YouTubeAdapter] Initialized successfully');
  }
  
  /**
   * Get current video ID from URL
   */
  getVideoId(): string | null {
    const url = new URL(window.location.href);
    
    // Standard watch URL
    if (url.pathname === '/watch') {
      return url.searchParams.get('v');
    }
    
    // Embed URL
    const embedMatch = url.pathname.match(/\/embed\/([^/?]+)/);
    if (embedMatch) {
      return embedMatch[1];
    }
    
    // youtu.be short URL
    if (url.hostname === 'youtu.be') {
      return url.pathname.slice(1).split('/')[0] || null;
    }
    
    // Try to get from player response
    return this.playerResponse?.videoDetails?.videoId ?? null;
  }
  
  /**
   * Get available subtitle tracks
   */
  async getSubtitleTracks(): Promise<SubtitleTrack[]> {
    const tracks: SubtitleTrack[] = [];
    
    // Get from player response (most reliable)
    if (this.playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks) {
      const captionTracks = this.playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;
      
      for (const track of captionTracks) {
        const label = track.name.simpleText || 
          track.name.runs?.map(r => r.text).join('') || 
          track.languageCode;
        
        tracks.push({
          id: track.vssId,
          language: track.languageCode,
          label,
          url: track.baseUrl,
          format: this.detectFormat(track.baseUrl),
          isAutoGenerated: track.kind === 'asr',
          isDefault: tracks.length === 0,
        });
      }
    }
    
    // Fallback: Get from captured requests
    if (tracks.length === 0) {
      for (const [id, subtitle] of this.capturedSubtitles) {
        tracks.push({
          id,
          language: subtitle.language,
          label: subtitle.label,
          url: subtitle.url,
          format: subtitle.format,
          isAutoGenerated: subtitle.isAutoGenerated,
          isDefault: tracks.length === 0,
        });
      }
    }
    
    console.log(`[YouTubeAdapter] Found ${tracks.length} subtitle tracks`);
    return tracks;
  }
  
  /**
   * Fetch subtitle content
   */
  async fetchSubtitle(track: SubtitleTrack): Promise<RawSubtitle> {
    console.log(`[YouTubeAdapter] Fetching subtitle: ${track.language}`);
    
    // First, check if we have captured content for this track
    const capturedId = `${track.language}-${track.isAutoGenerated ? 'asr' : 'manual'}`;
    const captured = this.capturedSubtitles.get(capturedId);
    
    if (captured?.content && captured.content.length > 0) {
      console.log(`[YouTubeAdapter] Using captured content for ${track.language}, length: ${captured.content.length}`);
      return {
        content: captured.content,
        format: this.detectFormatFromContent(captured.content),
        metadata: {
          videoId: this.getVideoId(),
          language: track.language,
          isAutoGenerated: track.isAutoGenerated,
        },
      };
    }
    
    // Try to find any captured subtitle with content (user may want to translate from different language)
    for (const [, subtitle] of this.capturedSubtitles) {
      if (subtitle.content && subtitle.content.length > 0) {
        console.log(`[YouTubeAdapter] Using available captured content from ${subtitle.language} (requested: ${track.language}), length: ${subtitle.content.length}`);
        return {
          content: subtitle.content,
          format: this.detectFormatFromContent(subtitle.content),
          metadata: {
            videoId: this.getVideoId(),
            language: subtitle.language,  // Use the actual captured language
            isAutoGenerated: subtitle.isAutoGenerated,
          },
        };
      }
    }
    
    // Fallback: fetch from URL (may not work due to token expiration)
    let url = track.url;
    if (!url.includes('fmt=')) {
      url += (url.includes('?') ? '&' : '?') + 'fmt=json3';
    }
    
    console.log(`[YouTubeAdapter] No captured content, fetching from URL:`, { url });
    
    try {
      // Use the original fetch to avoid interception issues
      const fetchFn = this.originalFetch || window.fetch;
      const response = await fetchFn.call(window, url, {
        credentials: 'include',
      });
      
      console.log(`[YouTubeAdapter] Fetch response:`, {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
      });
      
      if (!response.ok) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          `Failed to fetch subtitle: ${response.status} ${response.statusText}`,
          this.platform
        );
      }
      
      const content = await response.text();
      console.log(`[YouTubeAdapter] Content received:`, {
        length: content.length,
        preview: content.substring(0, 200),
      });
      
      if (content.length === 0) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          'Subtitle content is empty. The subtitle may have already been loaded. Please refresh the page and try again.',
          this.platform
        );
      }
      
      const format = this.detectFormatFromContent(content);
      
      return {
        content,
        format,
        metadata: {
          videoId: this.getVideoId(),
          language: track.language,
          isAutoGenerated: track.isAutoGenerated,
        },
      };
    } catch (error) {
      if (error instanceof AdapterError) {
        throw error;
      }
      throw new AdapterError(
        'SUBTITLE_FETCH_FAILED',
        `Failed to fetch subtitle: ${error instanceof Error ? error.message : 'Unknown error'}`,
        this.platform
      );
    }
  }
  
  /**
   * Inject translated subtitles
   */
  injectSubtitles(cues: Cue[], options: RenderOptions = DEFAULT_RENDER_OPTIONS): void {
    if (!this.videoElement) {
      console.warn('[YouTubeAdapter] No video element found');
      return;
    }
    
    if (!this.renderer) {
      this.renderer = createSubtitleRenderer();
    }
    
    this.renderer.attach(this.videoElement);
    this.renderer.setSubtitles(cues, options);
    this.renderer.setVisible(true);
    
    console.log(`[YouTubeAdapter] Injected ${cues.length} subtitles`);
  }
  
  /**
   * Remove injected subtitles
   */
  removeSubtitles(): void {
    if (this.renderer) {
      this.renderer.detach();
      this.renderer = null;
    }
  }
  
  /**
   * Get video element
   */
  getVideoElement(): HTMLVideoElement | null {
    return this.videoElement;
  }
  
  /**
   * Subscribe to video events
   */
  onVideoEvent(callback: VideoEventCallback): () => void {
    this.eventCallbacks.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.eventCallbacks.delete(callback);
    };
  }
  
  /**
   * Clean up
   */
  destroy(): void {
    console.log('[YouTubeAdapter] Destroying...');
    
    // Remove subtitles
    this.removeSubtitles();
    
    // Restore original XHR/fetch
    this.restoreInterception();
    
    // Clear state
    this.capturedSubtitles.clear();
    this.eventCallbacks.clear();
    this.videoElement = null;
    this.playerResponse = null;
    this.initialized = false;
  }
  
  // ============================================================================
  // Private Methods
  // ============================================================================
  
  /**
   * Setup XHR/fetch interception for timedtext API
   */
  private setupInterception(): void {
    // Store originals
    this.originalXHROpen = XMLHttpRequest.prototype.open;
    this.originalFetch = window.fetch;
    
    const adapter = this;
    
    // Override XHR
    XMLHttpRequest.prototype.open = function(
      method: string,
      url: string | URL,
      async?: boolean,
      username?: string | null,
      password?: string | null
    ) {
      const urlString = url.toString();
      const xhr = this;
      
      // Capture timedtext requests with their response
      if (adapter.isTimedTextUrl(urlString)) {
        // Add load listener to capture response
        xhr.addEventListener('load', function() {
          try {
            const content = xhr.responseText || xhr.response;
            if (content && typeof content === 'string' && content.length > 0) {
              adapter.captureSubtitleWithContent(urlString, content);
            } else {
              adapter.captureSubtitleUrl(urlString);
            }
          } catch (error) {
            console.warn('[YouTubeAdapter] Failed to capture XHR response:', error);
            adapter.captureSubtitleUrl(urlString);
          }
        });
      }
      
      // Call original
      return adapter.originalXHROpen!.call(
        this, 
        method, 
        url, 
        async ?? true, 
        username ?? null, 
        password ?? null
      );
    };
    
    // Override fetch
    window.fetch = async function(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
      let url: string;
      if (typeof input === 'string') {
        url = input;
      } else if (input instanceof URL) {
        url = input.toString();
      } else if (input instanceof Request) {
        url = input.url;
      } else {
        // Fallback for unexpected types
        url = String(input);
      }
      
      // For timedtext requests, capture the response body
      if (adapter.isTimedTextUrl(url)) {
        const response = await adapter.originalFetch!.call(window, input, init);
        
        // Clone the response so we can read the body and still return it
        const clonedResponse = response.clone();
        
        try {
          const content = await clonedResponse.text();
          adapter.captureSubtitleWithContent(url, content);
        } catch (error) {
          console.warn('[YouTubeAdapter] Failed to capture subtitle content:', error);
          adapter.captureSubtitleUrl(url);
        }
        
        return response;
      }
      
      return adapter.originalFetch!.call(window, input, init);
    };
    
    console.log('[YouTubeAdapter] XHR/fetch interception enabled');
  }
  
  /**
   * Restore original XHR/fetch
   */
  private restoreInterception(): void {
    if (this.originalXHROpen) {
      XMLHttpRequest.prototype.open = this.originalXHROpen;
      this.originalXHROpen = null;
    }
    
    if (this.originalFetch) {
      window.fetch = this.originalFetch;
      this.originalFetch = null;
    }
    
    console.log('[YouTubeAdapter] XHR/fetch interception restored');
  }
  
  /**
   * Check if URL is a timedtext API request
   */
  private isTimedTextUrl(url: string): boolean {
    return url.includes('timedtext') || 
           url.includes('/api/timedtext') ||
           url.includes('youtube.com/api/timedtext');
  }
  
  /**
   * Capture subtitle URL from request (without content)
   */
  private captureSubtitleUrl(url: string): void {
    try {
      const urlObj = new URL(url);
      const lang = urlObj.searchParams.get('lang') || 'unknown';
      const name = urlObj.searchParams.get('name') || lang;
      const kind = urlObj.searchParams.get('kind') || '';
      
      const id = `${lang}-${kind || 'manual'}`;
      
      this.capturedSubtitles.set(id, {
        url,
        language: lang,
        label: name,
        format: this.detectFormat(url),
        isAutoGenerated: kind === 'asr',
      });
      
      console.log(`[YouTubeAdapter] Captured subtitle URL: ${lang} (${kind || 'manual'})`);
    } catch (error) {
      console.warn('[YouTubeAdapter] Failed to parse subtitle URL:', error);
    }
  }
  
  /**
   * Capture subtitle URL with content from intercepted response
   */
  private captureSubtitleWithContent(url: string, content: string): void {
    try {
      const urlObj = new URL(url);
      const lang = urlObj.searchParams.get('lang') || 'unknown';
      const name = urlObj.searchParams.get('name') || lang;
      const kind = urlObj.searchParams.get('kind') || '';
      
      const id = `${lang}-${kind || 'manual'}`;
      
      this.capturedSubtitles.set(id, {
        url,
        language: lang,
        label: name,
        format: this.detectFormat(url),
        isAutoGenerated: kind === 'asr',
        content,  // Store the actual content
      });
      
      console.log(`[YouTubeAdapter] Captured subtitle with content: ${lang} (${kind || 'manual'}), length: ${content.length}`);
    } catch (error) {
      console.warn('[YouTubeAdapter] Failed to parse subtitle URL:', error);
    }
  }
  
  /**
   * Extract player response from page
   */
  private extractPlayerResponse(): void {
    try {
      // Try to get from ytInitialPlayerResponse
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const text = script.textContent || '';
        
        // Look for ytInitialPlayerResponse
        const match = text.match(/ytInitialPlayerResponse\s*=\s*(\{.+?\});/);
        if (match) {
          try {
            this.playerResponse = JSON.parse(match[1]) as PlayerResponse;
            console.log('[YouTubeAdapter] Extracted player response from script');
            return;
          } catch {
            // Continue searching
          }
        }
      }
      
      // Try window object
      const windowAny = window as unknown as { ytInitialPlayerResponse?: PlayerResponse };
      if (windowAny.ytInitialPlayerResponse) {
        this.playerResponse = windowAny.ytInitialPlayerResponse;
        console.log('[YouTubeAdapter] Got player response from window');
      }
    } catch (error) {
      console.warn('[YouTubeAdapter] Failed to extract player response:', error);
    }
  }
  
  /**
   * Observe video element changes
   */
  private observeVideoElement(): void {
    const findVideo = (): void => {
      const video = document.querySelector('video.html5-main-video') as HTMLVideoElement | null;
      
      if (video && video !== this.videoElement) {
        this.videoElement = video;
        this.setupVideoEventListeners(video);
        console.log('[YouTubeAdapter] Video element found');
      }
    };
    
    // Initial find
    findVideo();

    // Observe DOM changes
    const observer = new MutationObserver(() => {
      findVideo();
    });

    // Only observe if body exists
    if (document.body) {
      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
    } else {
      // Wait for body to exist using setTimeout
      const waitForBody = (): void => {
        if (document.body) {
          observer.observe(document.body, {
            childList: true,
            subtree: true,
          });
        } else {
          setTimeout(waitForBody, 10);
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForBody);
      } else {
        setTimeout(waitForBody, 10);
      }
    }
  }
  
  /**
   * Setup event listeners on video element
   */
  private setupVideoEventListeners(video: HTMLVideoElement): void {
    const dispatchEvent = (event: VideoEvent): void => {
      for (const callback of this.eventCallbacks) {
        try {
          callback(event);
        } catch (error) {
          console.error('[YouTubeAdapter] Event callback error:', error);
        }
      }
    };
    
    video.addEventListener('play', () => dispatchEvent({ type: 'play' }));
    video.addEventListener('pause', () => dispatchEvent({ type: 'pause' }));
    video.addEventListener('ended', () => dispatchEvent({ type: 'ended' }));
    
    video.addEventListener('seeked', () => {
      dispatchEvent({ type: 'seeked', currentTime: video.currentTime });
    });
    
    video.addEventListener('timeupdate', () => {
      dispatchEvent({ type: 'timeupdate', currentTime: video.currentTime });
    });
    
    video.addEventListener('ratechange', () => {
      dispatchEvent({ type: 'ratechange', playbackRate: video.playbackRate });
    });
  }
  
  /**
   * Detect subtitle format from URL
   */
  private detectFormat(url: string): SubtitleFormat {
    if (url.includes('fmt=json3') || url.includes('fmt=srv3')) {
      return 'json3';
    }
    if (url.includes('fmt=vtt')) {
      return 'webvtt';
    }
    // Default to json3 for YouTube
    return 'json3';
  }
  
  /**
   * Detect format from content
   */
  private detectFormatFromContent(content: string): SubtitleFormat {
    const trimmed = content.trim();
    
    if (trimmed.startsWith('{')) {
      return 'json3';
    }
    if (trimmed.startsWith('WEBVTT')) {
      return 'webvtt';
    }
    if (trimmed.startsWith('<?xml') || trimmed.startsWith('<tt')) {
      return 'ttml';
    }
    
    return 'json3';
  }
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create a YouTube adapter instance
 */
export function createYouTubeAdapter(): YouTubeAdapter {
  return new YouTubeAdapter();
}
