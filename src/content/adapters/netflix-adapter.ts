/**
 * Netflix Adapter
 * 
 * Handles subtitle interception and rendering for Netflix.
 * Uses JSON.parse hook to intercept manifest data containing subtitle URLs.
 * 
 * @see specs/001-ai-subtitle-translator/contracts/platform-adapter.md
 * @see FR-002: Netflix Support
 * @see FR-006: Subtitle Format Support (TTML)
 */

import type { Platform, SubtitleFormat, Cue } from '../../shared/types/subtitle';
import type {
  PlatformAdapter,
  URLPattern,
  SubtitleTrack,
  RawSubtitle,
  RenderOptions,
  VideoEventCallback,
} from './types';
import { AdapterError, DEFAULT_RENDER_OPTIONS } from './types';
import { createLogger } from '../../shared/utils/logger';

const log = createLogger('NetflixAdapter');

// ============================================================================
// Types
// ============================================================================

interface NetflixManifest {
  result?: {
    timedtexttracks?: NetflixTimedTextTrack[];
  };
}

interface NetflixTimedTextTrack {
  trackType: string;
  language: string;
  rawTrackType: string;
  isNoneTrack?: boolean;
  isForcedNarrative?: boolean;
  ttDownloadables?: {
    [format: string]: {
      urls: Array<{ url: string }>;
    };
  };
}

// ============================================================================
// Netflix Adapter
// ============================================================================

export class NetflixAdapter implements PlatformAdapter {
  readonly platform: Platform = 'netflix';
  
  readonly urlPatterns: URLPattern[] = [
    { pattern: /^https?:\/\/(?:www\.)?netflix\.com\/watch\//, type: 'main' },
  ];
  
  private videoElement: HTMLVideoElement | null = null;
  private subtitleTracks: SubtitleTrack[] = [];
  private eventListeners: Map<VideoEventCallback, () => void> = new Map();
  private subtitleOverlay: HTMLDivElement | null = null;
  private currentCues: Cue[] = [];
  private originalJsonParse: typeof JSON.parse | null = null;
  private originalFetch: typeof window.fetch | null = null;
  private originalXHROpen: typeof XMLHttpRequest.prototype.open | null = null;
  private capturedSubtitles: Map<string, { url: string; content: string; language: string }> = new Map();
  private initialized = false;
  private videoObserver: MutationObserver | null = null;
  
  // ============================================================================
  // Public Methods
  // ============================================================================
  
  canHandle(url: string): boolean {
    return this.urlPatterns.some(p => p.pattern.test(url));
  }
  
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    log.info('Initializing...');
    
    // Setup JSON.parse hook to intercept manifest
    this.setupJsonParseHook();
    
    // Setup XHR interception to capture subtitle content
    this.setupXHRInterception();
    
    // Setup fetch interception to capture subtitle content
    this.setupFetchInterception();
    
    // Wait for video element
    await this.waitForVideoElement();
    
    // Try to extract tracks from DOM after initialization
    setTimeout(() => this.extractTracksFromDOM(), 2000);
    
    this.initialized = true;
    log.info('Initialized');
  }
  
  getVideoId(): string | null {
    // Extract video ID from URL: netflix.com/watch/{videoId}
    const match = window.location.pathname.match(/\/watch\/(\d+)/);
    return match ? match[1] : null;
  }
  
  async getSubtitleTracks(): Promise<SubtitleTrack[]> {
    log.debug('getSubtitleTracks called', { currentTracks: this.subtitleTracks.length, captured: this.capturedSubtitles.size });
    
    // If we have captured subtitles but no tracks, create tracks from captures
    if (this.subtitleTracks.length === 0 && this.capturedSubtitles.size > 0) {
      for (const [lang, subtitle] of this.capturedSubtitles) {
        this.subtitleTracks.push({
          id: `captured-${lang}`,
          language: lang,
          label: this.getLanguageLabel(lang),
          url: subtitle.url,
          format: this.detectFormatFromContent(subtitle.content),
          isAutoGenerated: false,
          isDefault: this.subtitleTracks.length === 0,
        });
      }
      log.debug('Created tracks from captured subtitles', { count: this.subtitleTracks.length });
    }
    
    // If no tracks yet, wait briefly for captures (user may have just enabled subtitles)
    if (this.subtitleTracks.length === 0) {
      log.debug('No tracks found, waiting for subtitle capture...');
      
      // Wait up to 3 seconds for subtitle to be captured
      const waitResult = await this.waitForSubtitleCapture(3000);
      
      if (waitResult) {
        // Re-create tracks from newly captured subtitles
        for (const [lang, subtitle] of this.capturedSubtitles) {
          const existingTrack = this.subtitleTracks.find(t => t.language === lang);
          if (!existingTrack) {
            this.subtitleTracks.push({
              id: `captured-${lang}`,
              language: lang,
              label: this.getLanguageLabel(lang),
              url: subtitle.url,
              format: this.detectFormatFromContent(subtitle.content),
              isAutoGenerated: false,
              isDefault: this.subtitleTracks.length === 0,
            });
          }
        }
        log.debug('Created tracks after wait', { count: this.subtitleTracks.length });
      } else {
        log.info('No subtitles captured after waiting. Please enable subtitles in Netflix first.');
      }
    }
    
    return this.subtitleTracks;
  }
  
  /**
   * Wait for subtitle to be captured
   */
  private waitForSubtitleCapture(timeout: number): Promise<boolean> {
    return new Promise((resolve) => {
      // Check if already captured
      if (this.capturedSubtitles.size > 0) {
        resolve(true);
        return;
      }
      
      const startTime = Date.now();
      const checkInterval = 200; // Check every 200ms
      
      const check = (): void => {
        if (this.capturedSubtitles.size > 0) {
          resolve(true);
          return;
        }
        
        if (Date.now() - startTime >= timeout) {
          resolve(false);
          return;
        }
        
        setTimeout(check, checkInterval);
      };
      
      setTimeout(check, checkInterval);
    });
  }
  
  async fetchSubtitle(track: SubtitleTrack): Promise<RawSubtitle> {
    log.debug('Fetching subtitle', { trackId: track.id, language: track.language });
    
    // First check if we have captured content for this track
    const captured = this.capturedSubtitles.get(track.language);
    if (captured?.content && captured.content.length > 0) {
      log.debug('Using captured content', { language: track.language, length: captured.content.length });
      
      // Validate content before returning
      if (!this.isSubtitleContent(captured.content)) {
        log.warn('Captured content is not valid subtitle format');
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          'Captured content is not a valid subtitle format. Please try disabling and re-enabling subtitles in Netflix.',
          this.platform
        );
      }
      
      return {
        content: captured.content,
        format: this.detectFormatFromContent(captured.content),
        metadata: {
          language: track.language,
          trackId: track.id,
        },
      };
    }
    
    // Try to find any captured subtitle
    for (const [lang, subtitle] of this.capturedSubtitles) {
      if (subtitle.content && subtitle.content.length > 0) {
        log.debug('Using available captured content', { available: lang, requested: track.language });
        
        // Validate content before returning
        if (!this.isSubtitleContent(subtitle.content)) {
          log.warn('Captured content is not valid subtitle format');
          continue; // Try next captured subtitle
        }
        
        return {
          content: subtitle.content,
          format: this.detectFormatFromContent(subtitle.content),
          metadata: {
            language: lang,
            trackId: track.id,
          },
        };
      }
    }
    
    // Fallback: fetch from URL
    try {
      log.debug('No captured content, fetching from URL', { url: track.url });
      const fetchFn = this.originalFetch || window.fetch;
      const response = await fetchFn.call(window, track.url);
      
      if (!response.ok) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          `Failed to fetch subtitle: ${response.status}`,
          this.platform
        );
      }
      
      const content = await response.text();
      
      if (content.length === 0) {
        throw new AdapterError(
          'SUBTITLE_FETCH_FAILED',
          'Subtitle content is empty. Please enable subtitles in Netflix player first.',
          this.platform
        );
      }
      
      return {
        content,
        format: track.format,
        metadata: {
          language: track.language,
          trackId: track.id,
        },
      };
    } catch (error) {
      if (error instanceof AdapterError) throw error;
      
      throw new AdapterError(
        'SUBTITLE_FETCH_FAILED',
        `Failed to fetch subtitle: ${error instanceof Error ? error.message : 'Unknown error'}. Please enable subtitles in Netflix player first.`,
        this.platform
      );
    }
  }
  
  injectSubtitles(cues: Cue[], options: RenderOptions = DEFAULT_RENDER_OPTIONS): void {
    this.currentCues = cues;
    this.createOrUpdateOverlay(options);
    this.setupTimeSync();
    log.debug('Injected cues', { count: cues.length });
  }
  
  removeSubtitles(): void {
    if (this.subtitleOverlay) {
      this.subtitleOverlay.remove();
      this.subtitleOverlay = null;
    }
    this.currentCues = [];
  }
  
  getVideoElement(): HTMLVideoElement | null {
    if (!this.videoElement) {
      this.videoElement = document.querySelector('video');
    }
    return this.videoElement;
  }
  
  onVideoEvent(callback: VideoEventCallback): () => void {
    const video = this.getVideoElement();
    if (!video) {
      return () => {};
    }
    
    const handlers: Record<string, () => void> = {
      play: (): void => callback({ type: 'play' }),
      pause: (): void => callback({ type: 'pause' }),
      seeked: (): void => callback({ type: 'seeked', currentTime: video.currentTime }),
      timeupdate: (): void => callback({ type: 'timeupdate', currentTime: video.currentTime }),
      ended: (): void => callback({ type: 'ended' }),
      ratechange: (): void => callback({ type: 'ratechange', playbackRate: video.playbackRate }),
    };
    
    for (const [event, handler] of Object.entries(handlers)) {
      video.addEventListener(event, handler);
    }
    
    const cleanup = (): void => {
      for (const [event, handler] of Object.entries(handlers)) {
        video.removeEventListener(event, handler);
      }
      this.eventListeners.delete(callback);
    };
    
    this.eventListeners.set(callback, cleanup);
    return cleanup;
  }
  
  destroy(): void {
    log.info('Destroying...');

    // Disconnect video observer if still active
    if (this.videoObserver) {
      this.videoObserver.disconnect();
      this.videoObserver = null;
    }

    // Restore original JSON.parse
    if (this.originalJsonParse) {
      JSON.parse = this.originalJsonParse;
    }

    // Restore original fetch
    if (this.originalFetch) {
      window.fetch = this.originalFetch;
    }

    // Restore original XHR
    if (this.originalXHROpen) {
      XMLHttpRequest.prototype.open = this.originalXHROpen;
    }

    // Cleanup event listeners
    for (const cleanup of this.eventListeners.values()) {
      cleanup();
    }
    this.eventListeners.clear();

    // Clear captured subtitles
    this.capturedSubtitles.clear();

    // Remove overlay
    this.removeSubtitles();

    this.initialized = false;
  }
  
  // ============================================================================
  // Private Methods
  // ============================================================================
  
  /**
   * Setup JSON.parse hook to intercept Netflix manifest
   */
  private setupJsonParseHook(): void {
    this.originalJsonParse = JSON.parse;
    const self = this;

    JSON.parse = function(text: string, reviver?: (key: string, value: unknown) => unknown): unknown {
      // Safety check: if originalJsonParse is gone, use the built-in
      const jsonParse = self.originalJsonParse || JSON.parse;

      let result: unknown;
      try {
        result = jsonParse.call(this, text, reviver);
      } catch (error) {
        // If parsing fails, re-throw the error as the caller expects
        throw error;
      }

      // Check if this looks like a Netflix manifest with timed text tracks (wrap in try-catch)
      try {
        if (self.isNetflixManifest(result)) {
          log.debug('Intercepted Netflix manifest');
          self.extractSubtitleTracks(result as NetflixManifest);
        }
      } catch (error) {
        log.warn('Failed to extract from Netflix manifest', { error: String(error) });
      }

      return result;
    };

    log.debug('JSON.parse hook installed');

    // Also try to extract from existing Netflix player API
    this.tryExtractFromPlayerAPI();
  }
  
  /**
   * Try to extract subtitle tracks from Netflix's player API
   */
  private tryExtractFromPlayerAPI(): void {
    // Netflix stores player instance in window.netflix
    const windowAny = window as unknown as { 
      netflix?: { 
        appContext?: { 
          state?: { 
            playerApp?: { 
              getState?: () => { 
                videoPlayer?: { 
                  getAllPlayerSessionIds?: () => string[];
                  getVideoPlayerBySessionId?: (id: string) => {
                    getTimedTextTrackList?: () => Array<{
                      bcp47: string;
                      displayName: string;
                      trackId: string;
                      isForcedNarrative?: boolean;
                      isNoneTrack?: boolean;
                      cdnlist?: Array<{ url: string }>;
                    }>;
                  };
                };
              };
            };
          };
        };
      };
    };
    
    try {
      const playerState = windowAny.netflix?.appContext?.state?.playerApp?.getState?.();
      const videoPlayer = playerState?.videoPlayer;
      
      if (videoPlayer?.getAllPlayerSessionIds && videoPlayer?.getVideoPlayerBySessionId) {
        const sessionIds = videoPlayer.getAllPlayerSessionIds();
        
        for (const sessionId of sessionIds) {
          const player = videoPlayer.getVideoPlayerBySessionId(sessionId);
          const tracks = player?.getTimedTextTrackList?.();
          
          if (tracks && tracks.length > 0) {
            log.debug('Found tracks from player API', { count: tracks.length });
            this.extractTracksFromPlayerAPI(tracks);
            return;
          }
        }
      }
    } catch (error) {
      log.warn('Failed to extract from player API', error instanceof Error ? { error: error.message } : { error });
    }
    
    // Try again after a delay (player might not be ready)
    setTimeout(() => this.retryExtractFromDOM(), 2000);
  }
  
  /**
   * Extract tracks from Netflix player API format
   */
  private extractTracksFromPlayerAPI(tracks: Array<{
    bcp47: string;
    displayName: string;
    trackId: string;
    isForcedNarrative?: boolean;
    isNoneTrack?: boolean;
    cdnlist?: Array<{ url: string }>;
  }>): void {
    for (const track of tracks) {
      if (track.isNoneTrack || track.isForcedNarrative) continue;
      
      const url = track.cdnlist?.[0]?.url;
      if (!url) continue;
      
      this.subtitleTracks.push({
        id: track.trackId,
        language: track.bcp47,
        label: track.displayName || this.getLanguageLabel(track.bcp47),
        url,
        format: 'ttml' as SubtitleFormat,
        isAutoGenerated: false,
        isDefault: this.subtitleTracks.length === 0,
      });
    }
    
    log.debug('Extracted tracks from player API', { count: this.subtitleTracks.length });
  }
  
  /**
   * Try to extract subtitle info from DOM (fallback)
   */
  private retryExtractFromDOM(): void {
    if (this.subtitleTracks.length > 0) return;
    
    // Look for subtitle menu in DOM
    const subtitleItems = document.querySelectorAll('[data-uia="subtitle-item"]');
    
    if (subtitleItems.length > 0) {
      log.debug('Found subtitle items in DOM', { count: subtitleItems.length });
      // Note: DOM doesn't give us URLs, but we can at least detect available languages
      // User will need to trigger subtitle load by selecting from Netflix's menu
    }
    
    // Also check if tracks are now available
    this.tryExtractFromPlayerAPI();
  }
  
  /**
   * Extract tracks from DOM by looking at Netflix's subtitle panel
   */
  private extractTracksFromDOM(): void {
    // Try different selectors for Netflix's subtitle menu
    const selectors = [
      '[data-uia="subtitle-item"]',
      '.track-list-subtitles .track',
      '[class*="audio-subtitle"] [class*="track"]',
    ];
    
    for (const selector of selectors) {
      const items = document.querySelectorAll(selector);
      if (items.length > 0) {
        log.debug('Found subtitle items in DOM', { count: items.length, selector });
        break;
      }
    }
    
    // Also try to find and observe the subtitle text container for real-time capture
    this.observeSubtitleContainer();
  }
  
  /**
   * Observe Netflix's subtitle container for real-time text capture
   */
  private observeSubtitleContainer(): void {
    // Netflix displays subtitles in a player-timedtext container
    const findContainer = (): Element | null => {
      const selectors = [
        '.player-timedtext',
        '[class*="player-timedtext"]',
        '.timedtext-container',
        '[data-uia="player"] [class*="text-container"]',
      ];
      
      for (const selector of selectors) {
        const container = document.querySelector(selector);
        if (container) return container;
      }
      return null;
    };
    
    const container = findContainer();
    if (container) {
      log.debug('Found subtitle container, setting up observer');
      
      // Create a simple track from observed subtitles
      if (this.subtitleTracks.length === 0) {
        this.subtitleTracks.push({
          id: 'netflix-live',
          language: 'auto',
          label: 'Current Subtitle',
          url: '',  // No URL for live subtitles
          format: 'ttml' as SubtitleFormat,
          isAutoGenerated: false,
          isDefault: true,
        });
        log.debug('Created placeholder track for live subtitles');
      }
    }
  }
  
  /**
   * Setup XHR interception to capture subtitle content
   */
  private setupXHRInterception(): void {
    this.originalXHROpen = XMLHttpRequest.prototype.open;
    const adapter = this;
    
    // Override with a function that matches the expected signature
    XMLHttpRequest.prototype.open = function(
      this: XMLHttpRequest,
      method: string,
      url: string | URL,
      async: boolean = true,
      username?: string | null,
      password?: string | null
    ): void {
      const urlStr = url.toString();
      
      // Skip video/audio chunk URLs (they use /range/ pattern with large byte ranges)
      const isVideoChunk = /\/range\/\d+-\d+/.test(urlStr);
      
      // Only intercept potential subtitle URLs (not video chunks)
      if (!isVideoChunk && adapter.isPotentialSubtitleUrl(urlStr)) {
        this.addEventListener('load', function(this: XMLHttpRequest) {
          try {
            let content = '';
            
            // Try to get response text
            if (this.responseType === '' || this.responseType === 'text') {
              content = this.responseText || '';
            } else if (this.responseType === 'arraybuffer' && this.response) {
              try {
                const decoder = new TextDecoder('utf-8');
                content = decoder.decode(this.response as ArrayBuffer);
              } catch {
                // Not text content
              }
            }
            
            // Only capture if it's actually subtitle content (TTML/XML/VTT)
            if (content && adapter.isSubtitleContent(content)) {
              log.debug('Captured subtitle from XHR', { url: urlStr.substring(0, 80) });
              adapter.captureSubtitleContent(urlStr, content);
            }
          } catch {
            // Silently ignore errors
          }
        });
      }
      
      // Call original - always pass all arguments
      adapter.originalXHROpen!.call(this, method, url, async, username ?? null, password ?? null);
    };
    
    log.debug('XHR interception enabled');
  }
  
  /**
   * Check if URL might be a subtitle request (loose check)
   */
  private isPotentialSubtitleUrl(url: string): boolean {
    // Check for common subtitle-related patterns
    const patterns = [
      /\.dfxp/i,
      /\.ttml/i,
      /\.vtt/i,
      /\.srt/i,
      /\.xml/i,
      /timedtext/i,
      /textstream/i,
      /subtitles/i,
      /caption/i,
      /nflxvideo\.net/i,  // Netflix CDN - will be filtered by content check
    ];
    
    return patterns.some(p => p.test(url));
  }
  
  /**
   * Check if content is actually subtitle data
   */
  private isSubtitleContent(content: string): boolean {
    if (!content || content.length < 50) return false;
    
    // Remove BOM and trim for accurate detection
    const cleaned = content.replace(/^\uFEFF/, '').trim();
    
    // Must start with < for XML-based formats or WEBVTT
    if (!cleaned.startsWith('<') && !cleaned.startsWith('WEBVTT')) {
      return false;
    }
    
    // Check first 500 chars for subtitle signatures
    const sample = cleaned.substring(0, 500);
    
    return (
      sample.includes('<?xml') ||
      sample.includes('<tt ') ||
      sample.includes('<tt>') ||
      sample.includes('WEBVTT') ||
      sample.includes('<transcript') ||
      // TTML namespace
      sample.includes('http://www.w3.org/ns/ttml')
    );
  }
  
  /**
   * Setup fetch interception to capture subtitle content
   */
  private setupFetchInterception(): void {
    this.originalFetch = window.fetch;
    const adapter = this;
    
    window.fetch = async function(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
      let url: string;
      if (typeof input === 'string') {
        url = input;
      } else if (input instanceof URL) {
        url = input.href;
      } else if (input instanceof Request) {
        url = input.url;
      } else {
        // Fallback for unexpected types - try to convert to string
        url = String(input);
      }
      
      // Skip video/audio chunks
      const isVideoChunk = /\/range\/\d+-\d+/.test(url);
      
      // Debug: Log all non-chunk fetch requests to help diagnose subtitle capture issues
      if (!isVideoChunk && (url.includes('nflx') || url.includes('netflix'))) {
        log.debug('Fetch request', { url: url.substring(0, 120) });
      }
      
      // Check if this might be a subtitle request
      if (!isVideoChunk && adapter.isPotentialSubtitleUrl(url)) {
        log.debug('Potential subtitle URL detected', { url: url.substring(0, 100) });
        const response = await adapter.originalFetch!.call(window, input, init);
        const clonedResponse = response.clone();
        
        try {
          const content = await clonedResponse.text();
          log.debug('Fetch response content', { length: content.length, preview: content.substring(0, 100) });
          // Only capture if it's actually subtitle content
          if (content && adapter.isSubtitleContent(content)) {
            log.debug('Captured subtitle from fetch', { url: url.substring(0, 80) });
            adapter.captureSubtitleContent(url, content);
          } else {
            log.debug('Not subtitle content, skipping');
          }
        } catch (e) {
          log.warn('Failed to read fetch response', e instanceof Error ? { error: e.message } : { error: e });
        }
        
        return response;
      }
      
      return adapter.originalFetch!.call(window, input, init);
    };
    
    log.debug('Fetch interception enabled');
  }
  
  /**
   * Check if URL is a subtitle request (kept for compatibility, uses stricter check)
   */
  private isSubtitleUrl(url: string): boolean {
    // Netflix subtitle URLs patterns - must be specific to avoid matching video/audio chunks
    const patterns = [
      // Subtitle format indicators in URL
      /\.dfxp/i,
      /\.ttml/i,
      /\.vtt/i,
      /\.srt/i,
      /\.ncc/i,  // Netflix Closed Captions
      // Netflix API patterns
      /timedtext/i,
      /textstream/i,
      /subtitles/i,
      /\?.*textStreamUrl/i,
    ];
    
    // Exclude video/audio chunk URLs (they use /range/ pattern)
    if (/\/range\/\d+-\d+/.test(url)) {
      return false;
    }
    
    return patterns.some(p => p.test(url));
  }
  
  /**
   * Capture subtitle content from intercepted response
   */
  private captureSubtitleContent(url: string, content: string): void {
    // Try to detect language from content or URL
    let language = 'unknown';
    
    // Check for language in TTML content
    const langMatch = content.match(/xml:lang="([^"]+)"/);
    if (langMatch) {
      language = langMatch[1];
    }
    
    this.capturedSubtitles.set(language, {
      url,
      content,
      language,
    });
    
    log.debug('Captured subtitle content', { language, length: content.length });
    
    // If we don't have this language in tracks, add it
    const existingTrack = this.subtitleTracks.find(t => t.language === language);
    if (!existingTrack) {
      this.subtitleTracks.push({
        id: `captured-${language}`,
        language,
        label: this.getLanguageLabel(language),
        url,
        format: this.detectFormatFromContent(content),
        isAutoGenerated: false,
        isDefault: this.subtitleTracks.length === 0,
      });
    }
  }
  
  /**
   * Detect subtitle format from content
   */
  private detectFormatFromContent(content: string): SubtitleFormat {
    // Remove BOM and trim for accurate detection
    const cleaned = content.replace(/^\uFEFF/, '').trim();
    
    // Check for WEBVTT first (simpler check)
    if (cleaned.startsWith('WEBVTT') || cleaned.includes('WEBVTT')) {
      return 'webvtt';
    }
    
    // Check for TTML/XML
    if (cleaned.startsWith('<?xml') || cleaned.startsWith('<tt') || 
        cleaned.includes('<tt ') || cleaned.includes('<tt>') ||
        cleaned.includes('http://www.w3.org/ns/ttml')) {
      return 'ttml';
    }
    
    // If content doesn't look like a valid subtitle format, still return ttml
    // but log a warning - the parser will provide a better error message
    if (!cleaned.startsWith('<')) {
      log.warn('Content does not appear to be valid subtitle format', { preview: cleaned.substring(0, 100) });
    }
    
    return 'ttml';  // Netflix default
  }
  
  /**
   * Check if parsed JSON is a Netflix manifest
   */
  private isNetflixManifest(data: unknown): boolean {
    if (!data || typeof data !== 'object') return false;
    
    const manifest = data as NetflixManifest;
    return !!(manifest.result?.timedtexttracks);
  }
  
  /**
   * Extract subtitle tracks from manifest
   */
  private extractSubtitleTracks(manifest: NetflixManifest): void {
    const tracks = manifest.result?.timedtexttracks;
    if (!tracks || !Array.isArray(tracks)) return;
    
    this.subtitleTracks = [];
    
    for (const track of tracks) {
      // Skip none tracks and forced narrative
      if (track.isNoneTrack || track.isForcedNarrative) continue;
      
      // Only process SUBTITLES type
      if (track.trackType !== 'SUBTITLES') continue;
      
      // Get TTML URL (Netflix uses TTML primarily)
      const ttmlDownloadable = track.ttDownloadables?.['dfxp-ls-sdh'] || 
                               track.ttDownloadables?.['nflx-cmisc'] ||
                               track.ttDownloadables?.['simplesdh'];
      
      if (!ttmlDownloadable?.urls?.length) continue;
      
      const url = ttmlDownloadable.urls[0]?.url;
      if (!url) continue;
      
      this.subtitleTracks.push({
        id: `${track.language}-${track.rawTrackType}`,
        language: track.language,
        label: this.getLanguageLabel(track.language),
        url,
        format: 'ttml' as SubtitleFormat,
        isAutoGenerated: false,
        isDefault: track.rawTrackType === 'subtitles' || this.subtitleTracks.length === 0,
      });
    }
    
    log.debug('Extracted subtitle tracks', { count: this.subtitleTracks.length });
  }
  
  /**
   * Get human-readable language label
   */
  private getLanguageLabel(code: string): string {
    const labels: Record<string, string> = {
      'en': 'English',
      'zh': 'Chinese',
      'zh-TW': 'Chinese (Traditional)',
      'zh-CN': 'Chinese (Simplified)',
      'ja': 'Japanese',
      'ko': 'Korean',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'pt': 'Portuguese',
      'it': 'Italian',
      'ru': 'Russian',
    };
    return labels[code] || code;
  }
  
  /**
   * Wait for video element to be available
   */
  private waitForVideoElement(): Promise<HTMLVideoElement> {
    return new Promise((resolve) => {
      const video = document.querySelector('video');
      if (video) {
        this.videoElement = video;
        resolve(video);
        return;
      }

      // Store observer reference for cleanup
      this.videoObserver = new MutationObserver(() => {
        const video = document.querySelector('video');
        if (video) {
          this.videoElement = video;
          this.videoObserver?.disconnect();
          this.videoObserver = null;
          resolve(video);
        }
      });

      const startObserving = (): void => {
        if (document.body && this.videoObserver) {
          this.videoObserver.observe(document.body, {
            childList: true,
            subtree: true,
          });
        } else if (this.videoObserver) {
          setTimeout(startObserving, 10);
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startObserving);
      } else {
        startObserving();
      }

      // Timeout after 30 seconds
      setTimeout(() => {
        this.videoObserver?.disconnect();
        this.videoObserver = null;
        const video = document.querySelector('video');
        if (video) {
          this.videoElement = video;
          resolve(video);
        }
      }, 30000);
    });
  }
  
  /**
   * Create or update subtitle overlay
   */
  private createOrUpdateOverlay(options: RenderOptions): void {
    if (!this.subtitleOverlay) {
      this.subtitleOverlay = document.createElement('div');
      this.subtitleOverlay.className = 'ai-subtitle-overlay netflix-subtitle-overlay';
      this.subtitleOverlay.setAttribute('data-ai-subtitle', 'true');
      
      // Inject styles
      this.injectStyles(options);
      
      // Find player container
      const playerContainer = document.querySelector('.watch-video--player-view') ||
                             document.querySelector('.VideoContainer') ||
                             document.body;
      
      playerContainer.appendChild(this.subtitleOverlay);
    }
    
    // Update styles based on options
    this.updateOverlayStyles(options);
  }
  
  /**
   * Inject Netflix-specific styles
   */
  private injectStyles(options: RenderOptions): void {
    const styleId = 'ai-subtitle-netflix-styles';
    if (document.getElementById(styleId)) return;
    
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
      .netflix-subtitle-overlay {
        position: absolute;
        left: 0;
        right: 0;
        ${options.position === 'top' ? 'top: 10%;' : 'bottom: 10%;'}
        z-index: 100000;
        text-align: center;
        pointer-events: none;
        font-family: Netflix Sans, Helvetica Neue, Segoe UI, Roboto, Ubuntu, sans-serif;
      }
      
      .netflix-subtitle-overlay .subtitle-text {
        display: inline-block;
        padding: 4px 12px;
        font-size: ${options.fontSize}px;
        color: #fff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9),
                     -1px -1px 2px rgba(0, 0, 0, 0.5);
        max-width: 80%;
        line-height: 1.4;
      }
      
      .netflix-subtitle-overlay .subtitle-text.bilingual {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .netflix-subtitle-overlay .subtitle-text .original {
        font-size: ${Math.round(options.fontSize * 0.85)}px;
        opacity: 0.8;
      }
      
      .netflix-subtitle-overlay .subtitle-text .translated {
        font-size: ${options.fontSize}px;
      }
    `;
    document.head.appendChild(style);
  }
  
  /**
   * Update overlay styles
   */
  private updateOverlayStyles(options: RenderOptions): void {
    if (!this.subtitleOverlay) return;
    
    this.subtitleOverlay.style[options.position === 'top' ? 'top' : 'bottom'] = '10%';
    this.subtitleOverlay.style[options.position === 'top' ? 'bottom' : 'top'] = 'auto';
  }
  
  /**
   * Setup time synchronization
   */
  private setupTimeSync(): void {
    const video = this.getVideoElement();
    if (!video) return;
    
    // Initial update
    this.updateCurrentSubtitle(video.currentTime);
    
    // Listen for time updates
    this.onVideoEvent((event) => {
      if (event.type === 'timeupdate') {
        this.updateCurrentSubtitle(event.currentTime);
      } else if (event.type === 'seeked') {
        this.updateCurrentSubtitle(event.currentTime);
      }
    });
  }
  
  /**
   * Update displayed subtitle based on current time
   */
  private updateCurrentSubtitle(currentTime: number): void {
    if (!this.subtitleOverlay) return;
    
    // Find active cues
    const currentTimeMs = currentTime * 1000;
    const activeCues = this.currentCues.filter(
      cue => currentTimeMs >= cue.startTime && currentTimeMs < cue.endTime
    );
    
    if (activeCues.length === 0) {
      this.clearOverlay();
      return;
    }

    // Clear and rebuild using DOM APIs (Trusted Types compliant)
    this.clearOverlay();

    activeCues.forEach((cue, index) => {
      if (index > 0) {
        this.subtitleOverlay!.appendChild(document.createElement('br'));
      }

      const span = document.createElement('span');
      span.className = cue.translatedText ? 'subtitle-text bilingual' : 'subtitle-text';

      if (cue.translatedText) {
        const translatedSpan = document.createElement('span');
        translatedSpan.className = 'translated';
        translatedSpan.textContent = cue.translatedText;
        span.appendChild(translatedSpan);

        const originalSpan = document.createElement('span');
        originalSpan.className = 'original';
        originalSpan.textContent = cue.text;
        span.appendChild(originalSpan);
      } else {
        span.textContent = cue.text;
      }

      this.subtitleOverlay!.appendChild(span);
    });
  }

  /**
   * Clear overlay content (Trusted Types compliant)
   */
  private clearOverlay(): void {
    if (!this.subtitleOverlay) return;
    while (this.subtitleOverlay.firstChild) {
      this.subtitleOverlay.removeChild(this.subtitleOverlay.firstChild);
    }
  }
}

// ============================================================================
// Factory
// ============================================================================

export function createNetflixAdapter(): NetflixAdapter {
  return new NetflixAdapter();
}
